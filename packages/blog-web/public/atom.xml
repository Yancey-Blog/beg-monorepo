<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://yanceyleo.com/</id>
    <title>Yancey Blog</title>
    <updated>2021-10-13T03:22:37.197Z</updated>
    <generator>Yancey Inc.</generator>
    <author>
        <name>Yancey Leo</name>
        <email>yanceyofficial@gmail.com</email>
        <uri>https://yanceyleo.com/</uri>
    </author>
    <link rel="alternate" href="https://yanceyleo.com/"/>
    <subtitle>The Feed for Yancey Blog</subtitle>
    <logo>https://edge.yancey.app/beg/logo512.png</logo>
    <icon>https://yanceyleo.com/favicon.ico</icon>
    <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    <contributor>
        <name>Yancey Leo</name>
        <email>yanceyofficial@gmail.com</email>
        <uri>https://yanceyleo.com/</uri>
    </contributor>
    <entry>
        <title type="html"><![CDATA[手摸手教你高版本安卓安装 Charles 证书]]></title>
        <id>6e67b327-ae61-4dd9-b50a-24bfc82f8c34</id>
        <link href="https://yanceyleo.com/post/6e67b327-ae61-4dd9-b50a-24bfc82f8c34"/>
        <updated>2021-10-12T08:34:08.975Z</updated>
        <summary type="html"><![CDATA[众所周知(其实以前我也不知道), 在安卓 7 以上, 系统收敛了证书权限. 也就是说你在 Charles 下载了证书, 然后通过手机安装, 只会安装到用户列表中, 而安卓只信任系统级别的证书, 所以你安装的证书仍然不能访问 HTTPS.]]></summary>
        <content type="html"><![CDATA[<h2 id="解决方案">解决方案</h2>
<p><img src="https://edge.yancey.app/beg/thn9jsxa-1634026441468.png" alt="Charles 证书只存在于用户列表"></p>
<p><img src="https://edge.yancey.app/beg/mdpdqj50-1634026521272.png" alt="扑街图鉴"></p>
<p>这里使用小米 11 PRO 来演示. 首先你得把手机 root 掉, 当然猴米比较蛋疼, 得先解锁手机, 解锁手机需要先用小米账号申请, 申请成功后需要等待 168 小时(7 天) 才能解锁(注意解锁手机会抹掉手机数据); 解锁完毕后, 就可以在手机安装开发版 ROM 了, 注意这个 ROM 普通小米账号下载不到, 得是深度玩家账号. 因此我建议去某宝租一个小米账号, 一把梭. 这里不多赘述解锁和 root, 都是泪.</p>
<p>打开 Charles, 首先把证书下载下来.</p>
<p><img src="https://edge.yancey.app/beg/fjrw6oe6-1634026604637.png" alt="下载证书"></p>
<p>然后在终端执行下面的脚本. 注意, 下面的脚本是我从网上看到了, 然鹅我电脑的 openssl 是 v2.8.3(可通过 openssl version 查看版本), 但通过第二个脚本解析出来的不能用, 但第一个成功了, 很迷.</p>
<pre><code class="language-bash">#openssl版本在&lt;1.0执行上面

openssl x509 -inform PEM -subject_hash_old -in xxx.pem
        
#openssl版本&gt;1.0 执行下面

openssl x509 -inform PEM -subject_hash -in xxx.pem
</code></pre>
<p><img src="https://edge.yancey.app/beg/jewn9h90-1634027003982.png" alt="证书 hash"></p>
<p>记录上面图片中红框的 hash 值 <code>1dcbf3b0</code>, 将你的 <code>xxx.pem</code> 重命名成 <code>1dcbf3b0.0</code> 待用.</p>
<p>在电脑上安装 <code>adb</code>, 这玩意儿可以让你通过脚本跟安卓手机进行交互. 然后数据线连接你的手机, 记得打开 USB 调试模式.</p>
<pre><code>brew install --cask android-platform-tools
</code></pre>
<p>在终端执行 <code>adb devices</code>, 不出意外能看到你的手机, 找不到说明你手机没插好.</p>
<p><img src="https://edge.yancey.app/beg/wms7qgzk-1634027065945.png" alt="查找设备"></p>
<p>然后执行 <code>adb root</code>, 来切换到 root 模式.</p>
<p><img src="https://edge.yancey.app/beg/o4d074h9-1634027123275.png" alt="进入 root 权限"></p>
<p>使用 <code>adb disable-verify</code> 禁用安卓的系统验证.</p>
<p><img src="https://edge.yancey.app/beg/mvah872u-1634027187460.png" alt="禁用安卓的系统验证"></p>
<p>使用 <code>adb remount</code> 重新挂载下手机, 如果下一步执行不了, 可以执行下该步骤.</p>
<p><img src="https://edge.yancey.app/beg/2eo5qs93-1634027155339.png" alt="重新挂载手机"></p>
<p>最后通过如下命令, 将你修改后的证书传到系统认证根证书列表中.</p>
<pre><code>adb push Downloads/1dcbf3b0.0 /system/etc/security/cacerts/
</code></pre>
<p><img src="https://edge.yancey.app/beg/ziwt6axq-1634027240840.png" alt="复制证书到系统目录"></p>
<p>重启下手机, 就会发现系统下已经安装了 Charles 的证书. 愉快地抓包吧~</p>
<p><img src="https://edge.yancey.app/beg/c44wnsz3-1634027276343.png" alt="可以抓包啦!"></p>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2021-10-12T08:34:10.046Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introducing GraphQL]]></title>
        <id>3ed3d78b-bea8-42cf-8f8f-a215d06d06ac</id>
        <link href="https://yanceyleo.com/post/3ed3d78b-bea8-42cf-8f8f-a215d06d06ac"/>
        <updated>2021-09-26T07:00:22.255Z</updated>
        <summary type="html"><![CDATA[GraphQL 是一种用于 API 的查询语言, 并且提供已有数据查询的运行时, 它诞生于 2015 年, 由 Facebook 开发, 2018 年 11 月 7 日，Facebook 将 GraphQL 项目转移到新成立的 GraphQL 基金会. 目前 Facebook, Twitter, Netflix, PayPal 各厂已经在生产环境使用 GraphQL 了, GitHub API v4 也已全面使用 GraphQL.]]></summary>
        <content type="html"><![CDATA[<p><img src="https://edge.yancey.app/beg/ol37cccd-1632636908526.jpg" alt="原则"></p>
<h3 id="精准、可预测地返回数据">精准、可预测地返回数据</h3>
<p>传统的 RESTful 接口, 后端传递多少字段, 前端就得接收多少字段. 因此, 有时候前端只需要几个字段, 但后端返回一大串(尤其是历史悠久的接口), 这不但对前端筛选接口字段增加了难度, 还可能会造成潜在的性能问题. 而 GraphQL 使得客户端能够准确地获得它需要的数据, 而且没有任何冗余, 并且 GraphQL 筛选这些字段的过程不依赖于服务器, 而是它自己运行时.</p>
<pre><code class="language-ts">export const POSTS = gql`
  query Posts($input: PaginationInput!) {
    posts(input: $input) {
      total
      page
      pageSize
      items {
        _id
        title
        summary
      }
    }
  }
</code></pre>
<pre><code class="language-ts">@ObjectType()
export class SMSModel {
  @Field()
  @IsMobilePhone(&quot;zh-CN&quot;)
  @IsNotEmpty()
  public readonly phoneNumber: string;

  @Field()
  @Length(6)
  @IsNumberString()
  @IsNotEmpty()
  public readonly smsCode: string;
}
</code></pre>
<h3 id="只请求一个接口">只请求一个接口</h3>
<p>下面这个例子是一个经典的 RESTful 风格接口, 可以看到一套增删改查需要请求不同的 url, 这就导致了需要进行多个 TCP 连接. 虽然 HTTP2 提供了多路复用(同域名下所有通信都在单个连接上完成, 同个域名只需要占用一个 TCP 连接, 使用一个连接并行发送多个请求和响应)的特性. 但在网络仍然较慢的移动环境下, 我们仍希望尽可能的减少 HTTP 请求, GraphQL 的应用也能表现得足够迅速.</p>
<pre><code class="language-ts">GET /posts
GET /post/:id
POST /post
PUT /post/:id
DELETE /post/:id
</code></pre>
<pre><code class="language-ts">{
  operationName: &quot;Posts&quot;,
  query: &quot;...&quot;,
  variables: {
    input: {
      page: 1,
      pageSize: 10,
    },
  },
}
</code></pre>
<h2 id="sdlschema-definition-languages">SDL(schema definition languages)</h2>
<h3 id="type-language">Type Language</h3>
<p>GraphQL 不依赖于任何编程语言, 因为我们并不依赖于任何特定语言的句法句式, 它有自己的一套模式.</p>
<pre><code class="language-graphql">type Language {
  code: String!
  name: String!
  native: String!
}

type Location {
  geoname_id: Float!
  capital: String!
  languages: [Language!]!
  country_flag: String!
  country_flag_emoji: String!
  country_flag_emoji_unicode: String!
  calling_code: String!
  is_eu: Boolean!
  created_at: DateTime!
}
</code></pre>
<ol>
<li><code>Language</code> 代表 GraphQL <code>对象类型</code>, 一般用来约定后端的 response.</li>
<li><code>code</code>, <code>name</code>, <code>native</code> 是 <code>Language</code> 类型上的<code>字段</code>, 这意味着你在查询 <code>Language</code> 时只能查找这三个字段中的一个或多个, 查找任何其他字段将会报错.</li>
<li><code>code: String!</code> 意味着 <code>code</code> 的<strong>标量</strong>是 <code>String</code>, 感叹号意味着该字段是非空的, 如果后端返回改字段是空的, 也会报错.</li>
<li><code>languages: [Language!]!</code> 意味着 <code>languages</code> 的类型是 <code>Language 数组</code>, 且该数组不能为空.</li>
</ol>
<pre><code class="language-graphql">type Query {
  getPosts(input: PaginationInput!): PostModel!
}

type Mutation {
  createPost(input: CreatePostInput!): PostItemModel!
}

input CreatePostInput {
  posterUrl: String!
  title: String!
  summary: String!
  content: String!
  tags: [String!]!
  lastModifiedDate: String!
  isPublic: Boolean
}
</code></pre>
<p><code>Query</code> 和 <code>Mutation</code> 是两个内置的特殊类型, 你可以将其理解为 RESTful 中的 <code>GET</code> 和 <code>POST</code>, 前者用于查询, 后者用于增删改. 虽然使用 <code>Query</code> 可以进行增删改, 但为了语义化, 建议分开使用.</p>
<p>第一个语句定义一个查询, <code>getPost</code> 可以类比为 RESTful 接口中的路径; 而 <code>input</code> 则可以类比放在 body 中的参数, 它是 <code>CreatePostInput</code> 类型, 且是必传的, <code>input</code> 类型定义一次查询或变更中传递的对象参数; 该查询返回 <code>PostModel</code> 类型的数据, 且该数据必须为非空. 第二个语句定义一次变更, 语义同理.</p>
<h3 id="scalar">Scalar</h3>
<p>&quot;标量&quot;, 可以理解为 GraphQL 中字段的基础类型, 默认有 Int, Float, String, Boolean, ID 五种. 有时候你需要扩展适合自己业务的标量, 每个标量需要实现 <code>parseValue</code>, <code>serialize</code>, <code>parseLiteral</code> 三个方法, 如下是 <code>DateScalar</code>.</p>
<pre><code class="language-ts">import { Scalar, CustomScalar } from &quot;@nestjs/graphql&quot;;
import { Kind, ValueNode } from &quot;graphql&quot;;

@Scalar(&quot;Date&quot;)
export class DateScalar implements CustomScalar&lt;number, Date&gt; {
  description = &quot;Date custom scalar type&quot;;

  parseValue(value: number): Date {
    return new Date(value); // value from the client
  }

  serialize(value: Date): number {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast: ValueNode): Date {
    if (ast.kind === Kind.INT) {
      return new Date(ast.value);
    }
    return null;
  }
}
</code></pre>
<p>标量的目的是能够更加精确的确定一个字段的类型, 不过写个新的确实比较麻烦, 好在 <a href="https://www.graphql-scalars.dev/docs/usage/regex">graphql-scalars</a> 预设了大约 50 个标量, 比如 PositiveInt, NegativeInt, DateTime, Date, EmailAddress, HexColorCode 等等.</p>
<h3 id="enum">Enum</h3>
<p>枚举类型是一种特殊的标量, 它限制在一个特殊的可选值集合内. 这让你能够:</p>
<ol>
<li>验证这个类型的任何参数是可选值的某一个</li>
<li>与类型系统沟通, 一个字段总是一个有限值集合的其中一个值</li>
</ol>
<pre><code class="language-graphql">enum PostStatus {
  DRAFT
  PUBLISH
}
</code></pre>
<h3 id="interfaces">Interfaces</h3>
<p>跟许多类型系统一样, GraphQL 支持接口. 一个接口是一个抽象类型, 它包含某些字段, 而对象类型必须包含这些字段, 才能算实现了这个接口.</p>
<pre><code class="language-graphql">interface Common {
  status_msg: String!
  status_code: Int!
}

type User implements Common {
  id: ID!
  name: String!
  email: String!
  status_msg: String!
  status_code: Int!
}
</code></pre>
<h2 id="代码优先">代码优先</h2>
<p>在真实的开发中, 我们可以像上面一样, 通过编写 GraphQL 原生语言来创建 GraphQL SDL, 当然我们也可以通过代码优先的方式, 即通过 TypeScript 装饰器来生成. 下面的代码, 除了定义字段的类型, 比如 <code>posterUrl</code> 的类型是 <code>String</code> 标量, 且为非空; 还能&quot;夹带私货&quot;, 比如限制 <code>posterUrl</code> 是 <code>url</code> 格式的字符串, 这样就更加细粒度的对数据类型进行限制.</p>
<pre><code class="language-ts">@InputType()
export class CreatePostInput {
  @Field({ nullable: false })
  @IsString()
  @IsUrl({ protocols: [&quot;https&quot;], require_protocol: true })
  @IsNotEmpty()
  public readonly posterUrl: string;

  @Field({ nullable: false })
  @IsString()
  @MinLength(1)
  @MaxLength(20)
  @IsNotEmpty()
  public readonly title: string;

  @Field({ nullable: false })
  @IsString()
  @IsNotEmpty()
  public readonly summary: string;

  @Field({ nullable: false })
  @IsString()
  @IsNotEmpty()
  public readonly content: string;

  @Field(() =&gt; [String], { nullable: false })
  @IsArray()
  @IsString({ each: true })
  @ArrayNotEmpty()
  @ArrayUnique()
  @IsNotEmpty()
  public readonly tags: string[];

  @Field({ nullable: false })
  @IsString()
  @IsNotEmpty()
  public readonly lastModifiedDate: string;

  @Field({ nullable: true })
  public readonly isPublic?: boolean;
}
</code></pre>
<p>下面的代码则是 GraphQL 的解析器, 同样通过注解的方式来创建 Query 和 Mutation:</p>
<ul>
<li><code>@Query(() =&gt; PostItemModel)</code> 代表着返回值为 <code>PostItemModel</code> 类型;</li>
<li><code>getPostById</code> 定义这个查询的名称;</li>
<li><code>@Args({ name: &quot;id&quot;, type: () =&gt; ID })</code> 用来定义传参, 我需要传递一个字段 id, 它的标量为 ID</li>
</ul>
<pre><code class="language-ts">@Resolver()
export class PostsResolver {
  constructor(private readonly postsService: PostsService) {
    this.postsService = postsService;
  }

  @Query(() =&gt; PostItemModel)
  public async getPostById(@Args({ name: &quot;id&quot;, type: () =&gt; ID }) id: string) {
    return this.postsService.findOneById(id); // 处理 SQL
  }

  @Mutation(() =&gt; PostItemModel)
  @UseGuards(GqlAuthGuard)
  public async createPost(@Args(&quot;input&quot;) input: CreatePostInput) {
    return this.postsService.create(input); // 处理 SQL
  }
}
</code></pre>
<h2 id="前端">前端</h2>
<p><img src="https://edge.yancey.app/beg/bc4vglh0-1632634977155.jpg" alt="GrapqhQL"></p>
<p>GraphQL 在前端的本质表现就是向你的接口, 如 <code>https://api.example.com/graphql</code> 上发送一个 POST 请求, 而请求的 body 就如上图所示. 但为了更加的和 GrapqhQL 语法配合, 前端涌现了一些不错的库, 如 Facebook 自家的 <a href="https://relay.dev/">relay</a>, relay 经历了两次重大迭代, 目前 Facebook 官网用的是最新一代, 名字叫 relay morden.</p>
<p><img src="https://edge.yancey.app/beg/yjveqxkz-1632635487617.jpg" alt="facebook"></p>
<p>虽然 relay 是一个开源项目, 但它更多是为 Facebook 内部业务服务, 因此外部人用起来比较难受. 目前最广泛的框架则是 <a href="https://www.apollographql.com/">Apollo</a>, 它支持基于 Hooks 的 React 前端框架, 也支持 Vue, Angular, Android 和 iOS, 也提供了基于 Node.js 的后端框架 Appolo Server.</p>
<p><img src="https://edge.yancey.app/beg/fza63an6-1632635764280.jpg" alt="apollo"></p>
<p><code>fragment</code> 是用来定义片段, 如下面的例子, 我们定义查询一篇文章, 返回的是一篇文章实体; 修改一篇文章, 返回的也是文章修改后的实体. 这样它们的返回值基本都是一样的, 为了不写多次, 可以通过 fragment 来进行提取, 简化代码书写.</p>
<p>第二段代码, 请求的变更是 <code>createPost</code>, 它的参数 <code>input</code> 是 <code>CreatePostInput</code> 类型, 且为必传. 因为我们使用了 fragment, 因此需要将相应片段注入进来.</p>
<p>第三段代码就是真正在 jsx 中发起请求了, 通过 hooks 可以方便的处理请求体, loading, 返回值, 错误处理等等...</p>
<pre><code class="language-ts">const POST_FRAGMENT = gql`
  fragment PostFragment on PostItemModel {
    _id
    posterUrl
    title
    summary
    content
    tags
    lastModifiedDate
    like
    pv
    isPublic
    createdAt
    updatedAt
  }
`;

export const CREATE_ONE_POST = gql`
  mutation CreatePost($input: CreatePostInput!) {
    createPost(input: $input) {
      ...PostFragment
    }
  }
  ${POST_FRAGMENT}
`;

const [createPost, { loading }] = useMutation&lt;
  CreatePostMutation,
  CreatePostVars
&gt;(CREATE_ONE_POST, {
  onCompleted(data) {
    const newPost = data.createPost;
    enqueueSnackbar(&quot;Create success!&quot;, { variant: &quot;success&quot; });
  },
  onError() {},
});
</code></pre>
<h2 id="introspection">Introspection</h2>
<p>在真实的开发中, 我们会在后端定义一系列的 query, mutation, input, type, enum, scalar, interface. 而 GraphQL 支持一套强大的内省系统, 通过内省系统, 我们可以反查后端设计的 schema 的集合. 内省系统的另一个功能则是辅助开发 GraphQL 工具, 通过查询出来的内部 schema, 可以搭建出强大的 IDE. 如下代码可以查询出 <code>PostItemModel</code> 这个类型的所有信息.</p>
<pre><code class="language-graphql">{
  __type(name: &quot;PostItemModel&quot;) {
    name
    fields {
      name
      type {
        name
        kind
      }
    }
  }
}
</code></pre>
<pre><code class="language-ts">{
  &quot;data&quot;: {
    &quot;__type&quot;: {
      &quot;name&quot;: &quot;PostItemModel&quot;,
      &quot;fields&quot;: [
        {
          &quot;name&quot;: &quot;_id&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;posterUrl&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;title&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;summary&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;content&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;tags&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;lastModifiedDate&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;like&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;pv&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;isPublic&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;createdAt&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;updatedAt&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: null,
            &quot;kind&quot;: &quot;NON_NULL&quot;
          }
        },
        {
          &quot;name&quot;: &quot;prev&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: &quot;PostItemModel&quot;,
            &quot;kind&quot;: &quot;OBJECT&quot;
          }
        },
        {
          &quot;name&quot;: &quot;next&quot;,
          &quot;type&quot;: {
            &quot;name&quot;: &quot;PostItemModel&quot;,
            &quot;kind&quot;: &quot;OBJECT&quot;
          }
        }
      ]
    }
  }
}
</code></pre>
<h2 id="安全">安全</h2>
<h3 id="生产环境关闭-debug">生产环境关闭 <code>debug</code></h3>
<p>如果开启 <code>debug</code> 模式, 在出错时会展示错误的堆栈信息.</p>
<p><img src="https://edge.yancey.app/beg/dg0wpl8n-1632382810570.jpg" alt="debug 模式会展示堆栈信息"></p>
<h3 id="生产环境关闭-playground">生产环境关闭 <code>playground</code></h3>
<p><code>playground</code> 应当作为一种辅助自测工具, 其不应该暴露到线上.</p>
<h3 id="生产环境关闭-introspection">生产环境关闭 <code>introspection</code></h3>
<p>得益于内省, 可以轻松获取到 GraphQL server 内部的信息, 如各种类型, 标量等. 这些信息不应该在线上被三方直接通过代码采集到.</p>
<h3 id="控制多层深度的查询">控制多层深度的查询</h3>
<p>如下可能会造成昂贵的查询, 重则导致后端崩溃. 可以使用 <a href="https://github.com/stems/graphql-depth-limit">graphql-depth-limit</a> 来指定最多查询的层级.</p>
<pre><code class="language-graphql">query {
  author(id: 42) {
    posts {
      author {
        posts {
          author {
            posts {
              author {
                # and so on...
              }
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h3 id="控制分页数据量">控制分页数据量</h3>
<p>如下最多一次将能获取十万条数据, 显而易见会带来性能问题. 你可以通过 <a href="https://github.com/joonhocho/graphql-input-number">graphql-input-number</a> 在 resolver 中限制数字的最大值.</p>
<pre><code class="language-ts">query {
  authors(first: 1000) {
    name
    posts(last: 100) {
      title
      content
    }
  }
}
</code></pre>
<p>当然, 如果你使用了 <code>class-validator</code>, 也可以通过如下方式来限制.</p>
<pre><code class="language-ts">@InputType()
export class SomeNumberInput {
  @IsInt()
  @Min(1)
  @Max(10)
  public readonly pageSize: number;
}
</code></pre>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.apollographql.com/blog/graphql/security/9-ways-to-secure-your-graphql-api-security-checklist/">9 Ways To Secure your GraphQL API — GraphQL Security Checklist</a></li>
</ul>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2021-09-26T07:00:22.909Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入"时间管理大师" —— React Scheduler]]></title>
        <id>b55fde65-db55-4f9e-adb0-8bd7d194a56a</id>
        <link href="https://yanceyleo.com/post/b55fde65-db55-4f9e-adb0-8bd7d194a56a"/>
        <updated>2021-06-07T05:27:16.742Z</updated>
        <summary type="html"><![CDATA[众所周知 React 的愿景就是快速响应用户, 让用户觉得够快, 不能阻塞用户的交互. 而 Scheduler 作为 React 的调度中枢, 通过划分优先级, 时间切片, 可中断、可恢复任务等策略来保证高优任务先被执行, 以提高性能. 可谓"时间管理大师", 罗志祥本祥了.]]></summary>
        <content type="html"><![CDATA[<h2 id="什么是-scheduler">什么是 Scheduler</h2>
<p><a href="https://github.com/facebook/react/tree/master/packages/scheduler">Scheduler</a> 是内置于 React 项目下的一个包, <strong>你只需要将任务以及任务的优先级交给它, 它就可以帮你进行任务的协调调度</strong>. 目前 Scheduler 只被用于 React, 但团队的愿景是希望它能够更通用化.</p>
<h2 id="scheduler-用来做什么">Scheduler 用来做什么</h2>
<p>Scheduler 从宏观和微观对任务进行管控. 宏观上, 也就是对于多个任务, Scheduler 根据优先级来安排执行顺序; 而对于单个任务(微观上), 需要&quot;有节制&quot;的执行. 什么是&quot;有节制&quot;呢? 我们知道 JavaScript 是单线程的, 如果一个同步任务占用时间很长, 就会导致掉帧和卡顿. 因此需要把一个耗时的任务及时中断掉, 去执行更重要的任务(比如用户交互), 后续再执行该耗时任务, 如此往复. Scheduler 就是用这样的模式, 将任务细粒度切分, 来避免一直占用有限的资源执行耗时较长的任务, 实现更快的响应.</p>
<h2 id="原理综述">原理综述</h2>
<p>为了实现<strong>多个任务的管理</strong> 和 <strong>单个任务的控制</strong>, Scheduler 引入了两个概念: <strong>任务优先级</strong>, <strong>时间片</strong>. 任务优先级让任务按照自身的紧急程度排序, 这样可以让优先级最高的任务最先被执行到. 时间片规定的是单个任务在这一帧内最大的执行时间(<code>yieldInterval = 5ms</code>), 任务一旦执行时间超过时间片, 则会被打断, 转而去执行更高优的任务, 这样可以保证页面不会因为任务执行时间过长而产生掉帧或者影响用户交互.</p>
<h3 id="多个任务的管理">多个任务的管理</h3>
<p>在 Scheduler 中, 任务被分成了两种: <strong>未过期的任务</strong>和<strong>已过期的任务</strong>, 分别存储在 <code>timerQueue</code> 和 <code>taskQueue</code> 两个队列中.</p>
<h3 id="如何区分两种任务">如何区分两种任务</h3>
<p>通过任务的<strong>开始时间(startTime)</strong> 和 <strong>当前时间(currentTime)</strong> 比较:</p>
<ul>
<li>当 <code>startTime &gt; currentTime</code>, 说明未过期, 存到 <code>timerQueue</code></li>
<li>当 <code>startTime &lt;= currentTime</code>, 说明已过期, 存到 <code>taskQueue</code></li>
</ul>
<h3 id="入队的任务如何排序">入队的任务如何排序</h3>
<p>即便是区分了 <code>timerQueue</code> 和 <code>taskQueue</code>, 但每个队列中的任务也是有不同优先级的, 因此在入队时需要根据<strong>紧急程度</strong>将紧急的任务排在前面. 老版本的 React Scheduler 使用循环链表来串联, 代码比较难懂, 这里不展开.</p>
<p>目前源码中使用<a href="https://algorithm.yanceyleo.com/data-structure/tree/binary-heap"><strong>小顶堆</strong></a>这个数据结构实现, 堆是<a href="https://algorithm.yanceyleo.com/data-structure/queue/priority-queue">优先队列</a>的底层实现, 它在插入或者删除元素的时候, 通过&quot;上浮&quot;和&quot;下沉&quot;操作来使元素自动排序(优先队列经常用来解决算法中 <a href="https://algorithm.yanceyleo.com/leetcode/lcof/40-get-least-numbers">topK</a> 问题). 需要注意的是, 堆的元素存储在数组中, 而非链式结构. 关于二叉堆相关的逻辑本文不去展开, 有兴趣可以参考我学习<a href="https://algorithm.yanceyleo.com">数据结构与算法</a>的仓库.</p>
<p><img src="https://edge.yancey.app/beg/lld7yvf9th-1622692950075" alt="小顶堆"></p>
<p>回到源码, 当我们插入任务时, <code>timerQueue</code> 和 <code>taskQueue</code> 能保证元素是从小到大排序的. 那排序的依据是什么呢?</p>
<ul>
<li>timerQueue 中, 依据任务的开始时间(startTime)排序, 开始时间越早, 说明会越早开始, 开始时间小的排在前面. 任务进来的时候, 开始时间默认是当前时间, 如果进入调度的时候传了延迟时间, 开始时间则是当前时间与延迟时间的和.</li>
<li>taskQueue 中, 依据任务的过期时间(expirationTime)排序, 过期时间越早, 说明越紧急, 过期时间小的排在前面. 过期时间根据任务优先级计算得出, 优先级越高, 过期时间越早.</li>
</ul>
<h3 id="任务的执行">任务的执行</h3>
<ul>
<li>对于 <code>taskQueue</code>, 因为里面的任务已经过期了, 需要在 workLoop 中循环执行完这些任务</li>
<li>对于 <code>timerQueue</code>, 它里面的任务都不会立即执行, 但在 workLoop 方法中会通过 <code>advanceTimers</code> 方法来检测第一个任务是否过期, 如果过期了, 就放到 <code>taskQueue</code> 中.</li>
</ul>
<p>相较于单个任务的执行(马上会说到), 任务队列的管理属于宏观层面的范畴. 从 react-reconciler 计算的 Lane, 会被转化成 Scheduler 可识别的<strong>任务优先级</strong>, 然后通过它去管理任务队列中的任务顺序. 总之来讲, <strong>就是越紧急的任务, 它就需要被优先处理</strong>.</p>
<h3 id="单个任务的中断及恢复">单个任务的中断及恢复</h3>
<p>在循环 taskQueue 执行每一个任务时, 如果某个任务执行时间过长, 达到了时间片限制的时间, 那么该任务必须中断, 以便于让位给更重要的事情(如浏览器绘制), 等高优过期任务完成了, 再恢复执行该任务. Scheduler 要实现这样的调度效果需要两个角色: <strong>任务的调度者</strong>, <strong>任务的执行者</strong>. 调度者调度一个执行者, 执行者去循环 taskQueue, 逐个执行任务. 当某个任务的执行时间比较长, 执行者会根据时间片中断任务执行, 然后告诉调度者: 我现在正执行的这个任务被中断了, 还有一部分没完成, 但现在必须让位给更重要的事情, 你再调度一个执行者吧, 好让这个任务能在之后被继续执行完(任务的恢复). 于是, 调度者知道了任务还没完成, 需要继续做, 它会再调度一个执行者去继续完成这个任务. 通过执行者和调度者的配合, 可以实现任务的中断和恢复. 其实将任务挂起与恢复并不是一个新潮的概念, 它有一个名词叫做<a href="https://en.wikipedia.org/wiki/Coroutine"><strong>协程</strong></a>, ES6 之后的生成器, 就可以用 yield 关键字来模拟协程的概念.</p>
<p><img src="https://edge.yancey.app/beg/hrn331c8no-1622697039929" alt="time slice"></p>
<h2 id="源码解析">源码解析</h2>
<p>以上就是 Scheduler 的核心原理, talk is cheap, 想要真正搞懂, 还是得深入源码才行. 我切了个分支专门来读<a href="https://github.com/learn-frame/react/blob/feature/learn-react/packages/scheduler/src/forks/SchedulerDOM.js">React 源码</a>, 看完下面的内容可以再去 GayHub 上整体复习下.</p>
<h3 id="react-和-scheduler-优先级的转换">React 和 Scheduler 优先级的转换</h3>
<p>我们知道 React 的优先级采用的是 Lane 模型, 而 Scheduler 是一个独立的包, 有自己的一套优先级机制, 因此需要做一个转换. 这里摘录 <code>react-reconciler/src/ReactFiberWorkLoop.old(new).js</code> 中的一部分.</p>
<pre><code class="language-javascript">let newCallbackNode;
// 同步
if (newCallbackPriority === SyncLane) {
  // 执行 scheduleSyncCallback 方法
  // 只不过要区分下 legacy 模式还是 concurrent 模式
  // scheduleSyncCallback 自己有个 syncQueue, 用来承载同步任务
  // 并交由 flushSyncCallbacks 处理这些同步任务后, 再交由下面 scheduleCallback
  // 以最高优先级让 Scheduler 调度
  if (root.tag === LegacyRoot) {
    scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));
  } else {
    scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
  }

  // 这里我们只谈 scheduleCallback, 即以最高优先级
  // ImmediateSchedulerPriority 来执行同步任务
  if (supportsMicrotasks) {
    scheduleMicrotask(flushSyncCallbacks);
  } else {
    scheduleCallback(ImmediateSchedulerPriority, flushSyncCallbacks);
  }
  newCallbackNode = null;
} else {
  // 异步
  let schedulerPriorityLevel;
  // 需要将 lane 转换为 Scheduler 可识别的优先级
  switch (lanesToEventPriority(nextLanes)) {
    case DiscreteEventPriority:
      schedulerPriorityLevel = ImmediateSchedulerPriority;
      break;
    case ContinuousEventPriority:
      schedulerPriorityLevel = UserBlockingSchedulerPriority;
      break;
    case DefaultEventPriority:
      schedulerPriorityLevel = NormalSchedulerPriority;
      break;
    case IdleEventPriority:
      schedulerPriorityLevel = IdleSchedulerPriority;
      break;
    default:
      schedulerPriorityLevel = NormalSchedulerPriority;
      break;
  }
  // 通过 scheduleCallback 将任务及其优先级传入到 Scheduler 中
  newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root)
  );
}
</code></pre>
<h3 id="scheduler-中的优先级">Scheduler 中的优先级</h3>
<p>Scheduler 自身维护 6 种优先级, 不过翻了一遍源码 <code>NoPriority</code> 没被用过. 它们是计算 expirationTime 的重要依据, 而我们知道 expirationTime 事关 taskQueue 的排序. 该文件位于 <code>scheduler/src/SchedulerPriorities.js</code>.</p>
<pre><code class="language-javascript">export const NoPriority = 0; // 没有任何优先级
export const ImmediatePriority = 1; // 立即执行的优先级, 级别最高
export const UserBlockingPriority = 2; // 用户阻塞级别的优先级, 比如用户输入, 拖拽这些
export const NormalPriority = 3; // 正常的优先级
export const LowPriority = 4; // 低优先级
export const IdlePriority = 5; // 最低阶的优先级, 可以被闲置的那种
</code></pre>
<h3 id="schedulecallback">scheduleCallback</h3>
<p>通过上面的介绍, 我们知道 Scheduler 的主入口是 <code>scheduleCallback</code>, 它<strong>负责生成调度任务, 根据任务是否过期将任务放入 timerQueue 或 taskQueue, 然后触发调度行为, 让任务进入调度.</strong> 注意: <code>enableProfiling</code> 用来做一些审计和 debugger, 本文不去涉及.</p>
<ol>
<li>首先计算 <code>startTime</code>, 它被用作 <code>timerQueue</code> 排序的依据, <code>getCurrentTime()</code> 用来获取当前时间, 下面会讲到.</li>
<li>接着计算 <code>expirationTime</code>, 它被用作 <code>taskQueue</code> 排序的依据, 过期时间通过传入的优先级确定.</li>
<li><code>newTask</code> 是 Scheduler 中任务单元的数据结构, 注释写的很清楚, 其中 <code>sortIndex</code> 是优先队列(小顶堆)中排序的依据.</li>
<li>根据上面三步的铺垫, 这一步就是根据 <code>startTime</code> 和 <code>currentTime</code> 的关系将任务放到 timerQueue 或 taskQueue 之中, 然后触发调度行为.</li>
</ol>
<pre><code class="language-javascript">function unstable_scheduleCallback(priorityLevel, callback, options) {
  /*
   * (1
   */
  var currentTime = getCurrentTime();

  // timerQueue 根据 startTime 排序
  // 任务进来的时候, 开始时间默认是当前时间, 如果进入调度的时候传了延迟时间
  // 开始时间则是当前时间与延迟时间的和
  var startTime;
  if (typeof options === &quot;object&quot; &amp;&amp; options !== null) {
    var delay = options.delay;
    if (typeof delay === &quot;number&quot; &amp;&amp; delay &gt; 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  /*
   * (2
   */
  // taskQueue 根据 expirationTime 排序
  var timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT; // -1
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT; // 250
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT; // 1073741823 (2^30 - 1)
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT; // 10000
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT; // 5000
      break;
  }

  // 计算任务的过期时间, 任务开始时间 + timeout
  // 若是立即执行的优先级(IMMEDIATE_PRIORITY_TIMEOUT(-1))
  // 它的过期时间是 startTime - 1, 意味着立刻就过期
  var expirationTime = startTime + timeout;

  /*
   * (3
   */
  // 创建调度任务
  var newTask = {
    id: taskIdCounter++,
    callback, // 调度的任务
    priorityLevel, // 任务优先级
    startTime, // 任务开始的时间, 表示任务何时才能执行
    expirationTime, // 任务的过期时间
    sortIndex: -1, // 在小顶堆队列中排序的依据
  };

  if (enableProfiling) {
    newTask.isQueued = false;
  }

  /*
   * (4
   */
  // startTime &gt; currentTime 说明任务无需立刻执行
  // 故放到 timerQueue 中
  if (startTime &gt; currentTime) {
    // timerQueue 是通过 startTime 判断优先级的,
    // 故将 startTime 设为 sortIndex 作为优先级依据
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);

    // 如果 taskQueue 是空的, 并且当前任务优先级最高
    // 那么这个任务就应该优先被设为 isHostTimeoutScheduled
    if (peek(taskQueue) === null &amp;&amp; newTask === peek(timerQueue)) {
      // 如果超时调度已经在执行了, 就取消掉
      // 因为当前这个任务是最高优的, 需要先处理当前这个任务
      if (isHostTimeoutScheduled) {
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      }
      // Schedule a timeout.
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    // startTime &lt;= currentTime 说明任务已过期
    // 需将任务放到 taskQueue
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);

    if (enableProfiling) {
      markTaskStart(newTask, currentTime);
      newTask.isQueued = true;
    }

    // 如果目前正在对某个过期任务进行调度,
    // 当前任务需要等待下次时间片让出时才能执行
    if (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}
</code></pre>
<h3 id="getcurrenttime">getCurrentTime</h3>
<p>顾名思义, getCurrentTime 用来获取当前时间, 它优先使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><code>performance.now()</code></a>, 否则使用 <code>Date.now()</code>. 提起 performance 我们并不陌生, 它主要被用来收集性能指标. <code>performance.now()</code> 返回一个精确到毫秒的 <code>DOMHighResTimeStamp</code>(emmm, 一看到 HighRes 就想起大法).</p>
<p><img src="https://edge.yancey.app/beg/rc3v7cruxx-1622531131004" alt="Sony Hi-Res"></p>
<pre><code class="language-javascript">let getCurrentTime;
const hasPerformanceNow =
  typeof performance === &quot;object&quot; &amp;&amp; typeof performance.now === &quot;function&quot;;

if (hasPerformanceNow) {
  const localPerformance = performance;
  getCurrentTime = () =&gt; localPerformance.now();
} else {
  const localDate = Date;
  const initialTime = localDate.now();
  getCurrentTime = () =&gt; localDate.now() - initialTime;
}
</code></pre>
<p>稍微看了下 <a href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/timing/performance.cc;l=1107;drc=28684b63b1e1ece5396dc0e4c03118855710a75f;bpv=1;bpt=1">chromium 源码</a>(反正也看不懂啦),
大抵就是说 <code>performance.now()</code> 是个单调递增的时间(<code>monotonic_time</code>), 这保证了两个调用之间的差永远不会是负的;
此外还看到通过 <code>time_lower_digits</code> 和 <code>time_upper_digits</code> 来做了一些降噪处理, 保证计算结果不会太突兀. 此外还有什么<a href="https://w3c.github.io/hr-time/#dfn-coarsen-time">粗化时间算法(coarsen time algorithm)</a>就更尼玛看不懂了.</p>
<pre><code class="language-c++">DOMHighResTimeStamp Performance::now() const {
  return MonotonicTimeToDOMHighResTimeStamp(tick_clock_-&gt;NowTicks());
}
</code></pre>
<h3 id="requesthosttimeout-和-cancelhosttimeout">requestHostTimeout 和 cancelHostTimeout</h3>
<p>显然这是一对相爱相杀的好基友. 为了让一个<strong>未过期</strong>的任务能够到达<strong>恰好过期</strong>的状态, 那么需要延迟 <code>startTime - currentTime</code> 毫秒就可以了(其实它俩的差就是 XXX_PRIORITY_TIMEOUT), <code>requestHostTimeout</code> 就是来做这件事的, 而 <code>cancelHostTimeout</code> 就是用来取消这个超时函数的.</p>
<pre><code class="language-javascript">function requestHostTimeout(callback, ms) {
  taskTimeoutID = setTimeout(() =&gt; {
    callback(getCurrentTime());
  }, ms);
}

function cancelHostTimeout() {
  clearTimeout(taskTimeoutID);
  taskTimeoutID = -1;
}
</code></pre>
<h3 id="handletimeout">handleTimeout</h3>
<p><code>requestHostTimeout</code> 的第一个参数是 <code>handleTimeout</code>, 让我们来看看它是来做什么的. 首先调用了 advanceTimers 方法, 这个方法下面具体说, 它主要是用来<strong>更新 timerQueue 和 taskQueue 两个序列, 如果发现 timerQueue 有过期的, 就放到 taskQueue 中</strong>. 接下来如果没有正在调度任务, 就看看 taskQueue 中是否存在任务, 如果有的话就先 flush 掉; 否则就递归执行 <code>requestHostTimeout(handleTimeout, ...)</code>. 总之来讲, 这个方法就是要把 timerQueue 中的任务转移到 taskQueue 中.</p>
<pre><code class="language-javascript">function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  // 更新 timerQueue 和 taskQueue 两个序列
  // 如果发现 timerQueue 有过期的, 就放到 taskQueue 中
  advanceTimers(currentTime);

  // 检查是否已经开始调度
  // 如果正在调度, 就什么都不做
  if (!isHostCallbackScheduled) {
    // 如果 taskQueue 中有任务, 那就先去执行已过期的任务
    if (peek(taskQueue) !== null) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    } else {
      // 如果没有过期任务, 那就接着对最高优的第一个未过期的任务
      // 继续重复这个过程, 直到它可以被放置到 taskQueue
      const firstTimer = peek(timerQueue);
      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}
</code></pre>
<h3 id="advancetimers">advanceTimers</h3>
<p>这个方法就是用来检查 timerQueue 中的过期任务, 放到 taskQueue. 主要是对小顶堆的各种操作, 直接看注释即可.</p>
<pre><code class="language-javascript">function advanceTimers(currentTime) {
  let timer = peek(timerQueue);
  while (timer !== null) {
    if (timer.callback === null) {
      // Timer was cancelled.
      pop(timerQueue);

      // 开始时间小于等于当前时间, 说明已过期,
      // 从 taskQueue 移走, 放到 taskQueue
    } else if (timer.startTime &lt;= currentTime) {
      pop(timerQueue);
      // taskQueue 是通过 expirationTime 判断优先级的,
      // expirationTime 越小, 说明越紧急, 它就应该放在 taskQueue 的最前面
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);

      if (enableProfiling) {
        markTaskStart(timer, currentTime);
        timer.isQueued = true;
      }
    } else {
      // 开始时间大于当前时间, 说明未过期, 任务仍然保留在 timerQueue
      // 任务进来的时候, 开始时间默认是当前时间, 如果进入调度的时候传了延迟时间, 开始时间则是当前时间与延迟时间的和
      // 开始时间越早, 说明会越早开始, 排在最小堆的前面
      // Remaining timers are pending.
      return;
    }
    timer = peek(timerQueue);
  }
}
</code></pre>
<h3 id="requesthostcallback">requestHostCallback</h3>
<p>不管你接没接触过 React 源码, 想必也听到过<strong>时间切片, 任务中断可恢复</strong>这些概念. <code>requestHostCallback</code> 这个方法就是用来调度任务的. 既然是&quot;调度&quot;, 那势必得有指挥的和干活的.</p>
<p>旧的 React 版通过 <code>requestAnimationFrame</code> 和 <code>requestIdleCallback</code> 进行任务调度与帧对齐, 但在 <a href="https://github.com/facebook/react/pull/16214/commits">[scheduler] Yield many times per frame, no rAF #16214</a> 这个 pr 中, 这种方式被废弃了. 如果你看过我以前的一篇文章 <a href="https://www.yanceyleo.com/post/20506b75-0a04-450d-aeec-6ea08ef25116">剖析 requestAnimationFrame</a>, 就会发现 rAF 是会受到用户行为的干扰的, 比如切换选项卡, 滚动页面等. 看下面这张图, 前面一部分的斜率大抵就是 <code>16.7</code>, 也就是 <code>1 / 60</code>, 但我切换了选项卡之后, 帧刷新率立马不稳定了.</p>
<p><img src="https://edge.yancey.app/beg/77bab955-9126-4260-89e9-a89b45970fbe.jpg" alt="rAF 受到干扰"></p>
<p>此外, rAF 毕竟仰仗显示器的刷新频率, 而市面上的刷新频率层次不齐, 有 60Hz 的, 像苹果的 ProMotion 就到了 120Hz, <del>再加上好的显卡都被拿去挖矿了</del>, 兼容起来实在麻烦. 简言之, 这种方式会受到外界因素影响, 无法使 Scheduler 做到百分百掌控.</p>
<p><code>requestIdleCallback</code> 就不详细说了, 它可用在浏览器空闲阶段去执行一些低优先级任务, 而不会影响延迟关键事件, 如动画和输入响应. 具体使用方法可自行去看 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback">MDN</a> 上的介绍.</p>
<p>目前最新的代码中, Scheduler 通过 MessageChannel 来人为的控制调度频率, 默认的时间切片是 5ms, 可见这个粒度比 ProMotion 还要高. 如果你以前没听说过 MessageChannel, 但一定得听说过 postMessage 这家伙, 它经常被用做宿主跟 iframe 之间的通信. 此外它兼容性上也是好到没朋友.</p>
<p><img src="https://edge.yancey.app/beg/hstk3fzgbq-1622612290323" alt="MessageChannel"></p>
<p>铺垫的都说完了, 直接看源码. 它做了一波兼容, 如果是 Node.js 或者低端 IE, 就使用 <code>setImmediate</code>, 这块不展开说. 在正经的浏览器环境下(IE: 你直接念我身份证好了), 我们通过 MessageChannel 创建一个实例 channel, 该实例有两个 port, 用来互相通信. Scheduler 通过 port2 发送消息(<code>port.postMessage</code>), 通过 port1 来接收消息(<code>port1.onmessage</code>). 因此, port2 就是那个调度者, port1 是那个收到调度信号真正干活的.</p>
<pre><code class="language-javascript">let schedulePerformWorkUntilDeadline;

if (typeof setImmediate === &quot;function&quot;) {
  schedulePerformWorkUntilDeadline = () =&gt; {
    setImmediate(performWorkUntilDeadline);
  };
} else {
  const channel = new MessageChannel();
  const port = channel.port2;

  // port1 接收调度信号, 来执行 performWorkUntilDeadline(受)
  channel.port1.onmessage = performWorkUntilDeadline;

  // port 是调度者(攻)
  schedulePerformWorkUntilDeadline = () =&gt; {
    port.postMessage(null);
  };
}
</code></pre>
<p><code>requestHostCallback</code> 将传进来的 <code>callback</code> 赋值给全局变量 <code>scheduledHostCallback</code>, 如果当前 <code>isMessageLoopRunning</code> 是 false, 即没有任务调度, 就把它开启, 然后发送调度信号给 port1 进行调度.</p>
<pre><code class="language-javascript">function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;

    // postMessage, 告诉 port1 来执行 performWorkUntilDeadline 方法
    schedulePerformWorkUntilDeadline();
  }
}
</code></pre>
<h3 id="performworkuntildeadline">performWorkUntilDeadline</h3>
<p><code>performWorkUntilDeadline</code> 是任务的执行者, 也就是 port1 接收到信号后需要执行的函数, <strong>它用来在时间片内执行任务, 如果没执行完, 用一个新的调度者继续调度</strong>. 首先判断是否有 <code>scheduledHostCallback</code>, 如果存在说明存在需要被调度的任务. 计算 deadline 为当前时间加上 yieldInterval(也就是那 5ms). 看到这里相必你就恍然大悟了, deadline 其实就来做时间切片! 接下来设置了一个常量 <code>hasTimeRemaining</code> 为 true, 看到这俩名字你是不是想起了 <code>requestIdleCallback</code> 的用法了呢. 至于为什么 <code>hasTimeRemaining</code> 为 true, 因为不管你的整个任务是否执行完, 给你的时间就是 5ms, 要么超时就中断, 要么不超时就恰好执行完了, 总之时间切片内一定是有剩余时间的.</p>
<p>后面的逻辑直接看代码注释即可, 总结来讲就是任务在时间切片内没有被执行完, 就需要让调度者再次调度一个执行者继续执行任务, 否则这个任务就算执行完了. <strong>判断一个任务执行完成的标记是 hasMoreWork 字段, 下面 workLoop 会讲到</strong>.</p>
<pre><code class="language-javascript">const performWorkUntilDeadline = () =&gt; {
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime();
    // 时间分片
    deadline = currentTime + yieldInterval;
    const hasTimeRemaining = true;

    let hasMoreWork = true;
    try {
      // scheduledHostCallback 去执行真正的任务
      // 如果返回 true, 说明当前任务被中断了
      // 会再让调度者调度一个执行者继续执行任务
      // 下面讲 workLoop 方法时会说到中断恢复的逻辑, 先留个坑
      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
    } finally {
      if (hasMoreWork) {
        // 如果任务中断了(没执行完), 就说明 hasMoreWork 为 true
        // 这块类似于递归, 就再申请一个调度者来继续执行该任务
        schedulePerformWorkUntilDeadline();
      } else {
        // 否则当前任务就执行完了
        // 关闭 isMessageLoopRunning
        // 并将 scheduledHostCallback 置为 null
        isMessageLoopRunning = false;
        scheduledHostCallback = null;
      }
    }
  } else {
    isMessageLoopRunning = false;
  }
  // Yielding to the browser will give it a chance to paint, so we can
  // reset this.
  needsPaint = false;
};
</code></pre>
<h3 id="flushwork">flushWork</h3>
<p>我们早在 <code>requestHostCallback</code> 就将 <code>flushWork</code> 作为参数赋值给了全局变量 <code>scheduledHostCallback</code>, 在上面 <code>performWorkUntilDeadline</code> 也调用了该方法, 让我们看看 <code>flushWork</code> 用来做什么. 顾名思义, <code>flushWork</code> 就是把任务&quot;冲刷&quot;掉, <del>就好比 taskQueue 是马桶, 里面的任务是那啥, flushWork 就是冲水那套机制</del>. 当然剖丝抽茧, 该方法的核心就是 return 了 <code>workLoop</code>.</p>
<pre><code class="language-javascript">function flushWork(hasTimeRemaining, initialTime) {
  if (enableProfiling) {
    markSchedulerUnsuspended(initialTime);
  }

  // 由于 requestHostCallback 并不一定立即执行传入的回调函数
  // 所以 isHostCallbackScheduled 状态可能会维持一段时间
  // 等到 flushWork 开始处理任务时, 则需要释放该状态以支持其他的任务被 schedule 进来
  isHostCallbackScheduled = false;

  // 因为已经在执行 taskQueue 的任务了
  // 所以不需要等 timerQueue 中的任务过期了
  if (isHostTimeoutScheduled) {
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }

  isPerformingWork = true;
  const previousPriorityLevel = currentPriorityLevel;
  try {
    if (enableProfiling) {
      try {
        return workLoop(hasTimeRemaining, initialTime);
      } catch (error) {
        if (currentTask !== null) {
          const currentTime = getCurrentTime();
          markTaskErrored(currentTask, currentTime);
          currentTask.isQueued = false;
        }
        throw error;
      }
    } else {
      // No catch in prod code path.
      return workLoop(hasTimeRemaining, initialTime);
    }
  } finally {
    // 执行完任务后还原这些全局状态
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
    if (enableProfiling) {
      const currentTime = getCurrentTime();
      markSchedulerSuspended(currentTime);
    }
  }
}
</code></pre>
<h3 id="任务中断与恢复--workloop">任务中断与恢复 —— workLoop</h3>
<p>终于到了尾声, workLoop 可谓是集大成者, 承载了任务中断, 任务恢复, 判断任务完成等功能.</p>
<ul>
<li>循环 taskQueue 执行任务</li>
<li>任务状态的判断<ul>
<li>如果 taskQueue 执行完成了, 就返回 false, 并从 timerQueue 中拿出最高优的来做超时调度</li>
<li>如果未执行完, 说明当前调度发生了中断, 就返回 true, 下次接着调度(这个 Boolean 类型的返回值, 其实就对应着 <code>performWorkUntilDeadline</code> 中的 hasMoreWork)</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;

  // 因为是个异步的, 需要再次调整一下 timerQueue 跟 taskQueue
  advanceTimers(currentTime);

  // 最紧急的过期任务
  currentTask = peek(taskQueue);
  while (
    currentTask !== null &amp;&amp;
    !(enableSchedulerDebugging &amp;&amp; isSchedulerPaused) // 用于 debugger, 不管
  ) {
    // 任务中断!!!
    // 时间片到了, 但 currentTask 未过期, 跳出循环
    // 当前任务就被中断了, 需要放到下次 workLoop 中执行
    if (
      currentTask.expirationTime &gt; currentTime &amp;&amp;
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      // This currentTask hasn&#39;t expired, and we&#39;ve reached the deadline.
      break;
    }

    const callback = currentTask.callback;
    if (typeof callback === &quot;function&quot;) {
      // 清除掉 currentTask.callback
      // 如果下次迭代 callback 为空, 说明任务执行完了
      currentTask.callback = null;

      currentPriorityLevel = currentTask.priorityLevel;

      // 已过期
      const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;

      if (enableProfiling) {
        markTaskRun(currentTask, currentTime);
      }

      // 执行任务
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();

      // 如果产生了连续回调, 说明出现了中断
      // 故将新的 continuationCallback 赋值 currentTask.callback
      // 这样下次恢复任务时, callback 就接上趟了
      if (typeof continuationCallback === &quot;function&quot;) {
        currentTask.callback = continuationCallback;

        if (enableProfiling) {
          markTaskYield(currentTask, currentTime);
        }
      } else {
        if (enableProfiling) {
          markTaskCompleted(currentTask, currentTime);
          currentTask.isQueued = false;
        }
        // 如果 continuationCallback 不是 Function 类型, 说明任务完成!!!
        // 否则, 说明这个任务执行完了, 可以被弹出了
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }

      // 上面执行任务会消耗一些时间, 再次重新更新两个队列
      advanceTimers(currentTime);
    } else {
      // 上面的 if 清空了 currentTask.callback, 所以
      // 如果 callback 为空, 说明这个任务就执行完了, 可以被弹出了
      pop(taskQueue);
    }

    // 如果当前任务执行完了, 那么就把下一个最高优的任务拿出来执行, 直到清空了 taskQueue
    // 如果当前任务没执行完, currentTask 实际还是当前的任务, 只不过 callback 变成了 continuationCallback
    currentTask = peek(taskQueue);
  }

  // 任务恢复!!!
  // 上面说到 ddl 到了, 但 taskQueue 还没执行完(也就是任务被中断了)
  // 就返回 true, 这就是恢复任务的标志
  if (currentTask !== null) {
    return true;
  } else {
    // 若任务完成!!!, 去 timerQueue 中找需要最早开始执行的那个任务
    // 进行 requestHostTimeout 调度那一套
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
</code></pre>
<h3 id="shouldyieldtohost">shouldYieldToHost</h3>
<p>这个方法没啥可说的, 就是判断是否要让出主线程. 不过它引申出一个比较新潮的 API 即 <code>navigator.scheduling.isInputPending</code>, 它用来再不让出主线程的情况下提高响应能力, 不过 Chrome 90 还没有该 API, 想必这是个面向未来的. <a href="https://web.dev/isinputpending/">Better JS scheduling with isInputPending()</a> 讲得不错, 可以看看.</p>
<pre><code class="language-javascript">function shouldYieldToHost() {
  if (
    enableIsInputPending &amp;&amp;
    navigator !== undefined &amp;&amp;
    navigator.scheduling !== undefined &amp;&amp;
    navigator.scheduling.isInputPending !== undefined
  ) {
    const scheduling = navigator.scheduling;
    const currentTime = getCurrentTime();
    if (currentTime &gt;= deadline) {
      // There&#39;s no time left. We may want to yield control of the main
      // thread, so the browser can perform high priority tasks. The main ones
      // are painting and user input. If there&#39;s a pending paint or a pending
      // input, then we should yield. But if there&#39;s neither, then we can
      // yield less often while remaining responsive. We&#39;ll eventually yield
      // regardless, since there could be a pending paint that wasn&#39;t
      // accompanied by a call to `requestPaint`, or other main thread tasks
      // like network events.
      // 需要绘制或者有高优先级的 I/O, 必须得让出主线程
      if (needsPaint || scheduling.isInputPending()) {
        // There is either a pending paint or a pending input.
        return true;
      }
      // There&#39;s no pending input. Only yield if we&#39;ve reached the max
      // yield interval.
      return currentTime &gt;= maxYieldInterval;
    } else {
      // There&#39;s still time left in the frame.
      return false;
    }
  } else {
    // `isInputPending` is not available. Since we have no way of knowing if
    // there&#39;s pending input, always yield at the end of the frame.

    // task 执行超过了 ddl 就应该让出主进程了
    return getCurrentTime() &gt;= deadline;
  }
}
</code></pre>
<h3 id="取消调度">取消调度</h3>
<p>在 workLoop 的代码中有一段是 <code>currentTask.callback = null;</code>, 也就是 Scheduler 以 callback 是否为 null 来判断任务被取消(或者完成了).</p>
<pre><code class="language-javascript">function unstable_cancelCallback(task) {
  if (enableProfiling) {
    if (task.isQueued) {
      const currentTime = getCurrentTime();
      markTaskCanceled(task, currentTime);
      task.isQueued = false;
    }
  }

  // Null out the callback to indicate the task has been canceled. (Can&#39;t
  // remove from the queue because you can&#39;t remove arbitrary nodes from an
  // array based heap, only the first one.)
  task.callback = null;
}
</code></pre>
<h3 id="自定义的时间切片频率">自定义的时间切片频率</h3>
<p>为了后续 Scheduler 独立成包, 它开放了设置时间切片的大小, 默认为 5ms, 你可以根据实际情况调整到 0 ~ 125 之间. 不过怎么把握这个度, 咱也不知道咱也不敢问.</p>
<pre><code class="language-javascript">function forceFrameRate(fps) {
  if (fps &lt; 0 || fps &gt; 125) {
    // Using console[&#39;error&#39;] to evade Babel and ESLint
    console[&quot;error&quot;](
      &quot;forceFrameRate takes a positive int between 0 and 125, &quot; +
        &quot;forcing frame rates higher than 125 fps is not supported&quot;
    );
    return;
  }
  if (fps &gt; 0) {
    yieldInterval = Math.floor(1000 / fps);
  } else {
    // reset the framerate
    yieldInterval = 5;
  }
}
</code></pre>
<h2 id="最后">最后</h2>
<p>以上全部就是 Scheduler 的源码解析了, 洋洋洒洒两万余字, 一大半都是代码... 除此之外源码中还有一些通用逻辑的封装, 以及一些面向未来的特性文中没有涉及, 有兴趣可以去 GayHub 上翻源码看看. 本文基于 v17.0.2, 未来谁也没法保证它的代码会变成啥样, 先看先享受, 且行且珍惜. 后面如有大的更新, 我会尽力更新文章, 以保证和 master 对齐. 读源码这事儿, 不是一朝一夕的事儿, 也不能只一家之言, 欢迎大家拍砖提意见. 实在是画图苦手, 盗用 shockw4ver 大佬的一张流程图收尾.</p>
<p><img src="https://edge.yancey.app/beg/5scdbn97g8-1622629716400" alt="5scdbn97g8-1622629716400"></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://github.com/7kms/react-illustration-series/blob/master/docs/main/priority.md">React 中的优先级管理</a></li>
<li><a href="https://github.com/7kms/react-illustration-series/blob/master/docs/main/scheduler.md">React 调度原理(scheduler)</a></li>
<li><a href="https://segmentfault.com/a/1190000022942008">探索 React 的内在 —— postMessage &amp; Scheduler</a></li>
<li><a href="https://segmentfault.com/a/1190000039101758">一篇长文帮你彻底搞懂 React 的调度机制原理</a></li>
<li><a href="https://juejin.cn/post/6844903975112671239">这可能是最通俗的 React Fiber(时间分片) 打开方式</a></li>
</ul>
<p><img src="https://edge.yancey.app/beg/%E9%BD%8B%E8%97%A4%E9%A3%9B%E9%B3%A5.gif" alt="齋藤飛鳥"></p>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2021-06-03T06:21:41.170Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[从 React 源码谈 v8 引擎对数组的内部处理]]></title>
        <id>6af49c12-807b-40be-b65b-028f201e4808</id>
        <link href="https://yanceyleo.com/post/6af49c12-807b-40be-b65b-028f201e4808"/>
        <updated>2021-09-12T20:29:31.865Z</updated>
        <summary type="html"><![CDATA[前段时间在看 Lane(以前叫做 expirationTime) 相关的代码时, 被 v8 引擎的这个注释给吸引到了. 打开研究了一番, 发现创建数组的形式不同, v8 内部的处理也不同, 因此适当的方式会对性能大有裨益, 本文做一个记录.]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>这篇文章翻译自 <a href="https://v8.dev/blog/elements-kinds#avoid-creating-holes">Elements kinds in V8</a>, 可配合 Mathias Bynens 的一篇演讲视频 <a href="https://www.youtube.com/watch?v=m9cTaYI95Zc"><em>V8 internals for JavaScript developers</em></a> 一同观看.</p>
<pre><code class="language-embeded">&lt;iframe width=&quot;100%&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/m9cTaYI95Zc&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt; &lt;/iframe&gt;
</code></pre>
<h2 id="从-react-的源码说起">从 React 的源码说起</h2>
<pre><code class="language-ts">export function createLaneMap&lt;T&gt;(initial: T): LaneMap&lt;T&gt; {
  // Intentionally pushing one by one.
  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
  const laneMap = [];
  for (let i = 0; i &lt; TotalLanes; i++) {
    laneMap.push(initial);
  }
  return laneMap;
}
</code></pre>
<p>先简单介绍一下 <code>createLaneMap</code> 这个方法, 它是用来初始化 FiberRoot 对象中的 <code>eventTimes</code>, <code>expirationTimes</code>, <code>entanglements</code> 属性, 其中 <code>TotalLanes</code> 是常量 31, 这是因为 Lane 是由 32 位二进制来表示的, 去除二进制的前导 <code>0b</code>, 正好是长度是 31, 如 <code>0b0000000000000000000000000000000</code>.</p>
<h2 id="正文">正文</h2>
<p>JavaScript 中对象的属性可以是任意类型, 这意味着它们可以是 numeric, 可以是 Symbol, 甚至你用 undefined, null, Date 等等作为 key 都无所谓. 而对于 key 是 numeric 的情形, JavaScript 引擎是做了一些优化的, 其中最典型的就是数组索引了.</p>
<p>在 V8 中, 具有整数名称的属性(最常见的形式是由 Array 构造函数生成的对象, 也就是 <code>new Array()</code>)会得到特别处理. 尽管在许多情况下这些数字索引属性的行为与其他属性一样, 但是 V8 出于优化目的选择将它们与非数字属性分开存储. 在内部, V8 甚至给这些属性一个特殊的名称: <strong>元素</strong>. 对象具有映射到<strong>值</strong>的<strong>属性</strong>, 而数组具有映射到<strong>元素</strong>的<strong>索引</strong>.</p>
<p>虽然这些内部代码从未直接暴露给 JavaScript 开发人员, 但它们解释了为什么某些代码模式比其他代码模式更快.</p>
<h2 id="common-element-kinds">Common element kinds</h2>
<p>在 JavaScript 代码的运行时, V8 会对数组中的每个 element kinds 保持跟踪. 这些跟踪信息允许 V8 来对数组中的指定类型做一些优化. 举个栗子, 在你调用 reduce, map 或者 forEach 的时候, V8 可以根据数组包含的 element kinds 优化这些操作. 对于 JavaScript 来说, 它不会区分一个数字是 integers, floats, 亦或 doubles, 但在 V8 内部会有一个精确的区分.</p>
<p>考察下面代码: 数组一开始为 <code>[1, 2, 3]</code>, 它的 element kinds(elements kind)在 v8 引擎内部被定义成 <code>PACKED_SMI_ELEMENTS</code>; 我们追加一个浮点型数字, element kinds 变成了 <code>PACKED_DOUBLE_ELEMENTS</code>, 而当我们再追加进一个字符串类型的元素时, element kinds 变成了 <code>PACKED_ELEMENTS</code>.</p>
<pre><code class="language-ts">const arr = [1, 2, 3]; // PACKED_SMI_ELEMENTS

arr.push(4.56); // PACKED_DOUBLE_ELEMENTS

arr.push(&quot;x&quot;); // PACKED_ELEMENTS
</code></pre>
<p>即便我们此时并不知道以上三种 elements kinds 的区别, 但也能隐隐感受到, v8 肯定会对纯 Int 类型元素的数组做些什么优化. 下面来具体认识一下这三种标记:</p>
<ul>
<li>SMI 是 <strong>Sm</strong>all <strong>i</strong>ntegers 的缩写</li>
<li>如果有双精度元素, 数组会被标记成 <code>PACKED_DOUBLE_ELEMENTS</code></li>
<li>对于有普通类型元素的, 数组会被标记成 <code>PACKED_ELEMENTS</code></li>
</ul>
<p>需要注意的是, element kinds 的转换是<strong>不可逆</strong>的, 并且方向只能从特殊到一般, 这就意味着从 <code>PACKED_SMI_ELEMENTS</code> 可以到 <code>PACKED_DOUBLE_ELEMENTS</code>, 但反之不行, 即便你后面再把 <code>4.56</code> 移除掉, 这个数组仍然会是 <code>PACKED_DOUBLE_ELEMENTS</code>.</p>
<p>稍作总结, 我们可以看到 v8 为数组做了这些事:</p>
<ul>
<li>v8 会给每个数组指定 element kinds</li>
<li>element kinds 不是一成不变的, 随着我们对数组操作, 它会在运行时发生变化</li>
<li>element kinds 的转换是<strong>不可逆</strong>的, 并且方向只能从特殊到一般</li>
</ul>
<h2 id="packed-vs-holey-kinds">PACKED vs. HOLEY kinds</h2>
<p>上面几种标记都是针对的<strong>密集</strong>数组. 什么是<strong>密集</strong>数组呢? 比如 <code>[1, 2, 4.56, &#39;x&#39;]</code>, 它的 length 是 4, 并且这四个位置<strong>在初始化的时候</strong>都有元素.</p>
<p>与此相反便是<strong>稀疏</strong>数组了, 比如下面这个例子: 原本数组为 <code>PACKED_ELEMENTS</code>, 但我们在 <code>arr[8]</code> 的位置设置了一个元素, 众所周知数组内存分配空间是按照长度来的, 这就导致 <code>arr[5] ~ arr[7]</code> 什么都没有, 对于这种数组, 它的 elements kind 被标记成了 <code>HOLEY_ELEMENTS</code>.</p>
<pre><code class="language-ts">// HOLEY_ELEMENTS
const arr = [1, 2, 4.56, &quot;x&quot;];
arr[8] = &quot;hahaha&quot;;
</code></pre>
<p>v8 之所以做出这样的区别, 是因为操作一个 packed array 会比 holey array 得到更多的优化. 对于 packed array, 大多数操作可以高效的执行, 而操作 holey array, 需要额外付出昂贵的代价来检查原型链(这里后面会说到).</p>
<h2 id="elements-kind-转化关系">elements kind 转化关系</h2>
<p>到此为止, 基本的 elements kind 的转化关系我们就介绍完了. 当然 v8 目前一共提供了 <a href="https://cs.chromium.org/chromium/src/v8/src/elements-kind.h?l=14&amp;rcl=ec37390b2ba2b4051f46f153a8cc179ed4656f5d">21 种不同的 elements kind</a>, 都在 <code>ElementsKind</code> 这个枚举类型中, 每种类型都有它不同的优化方案.</p>
<p>通过这张图, 我们看到转化关系是不可逆的, 且只能从特殊类型到普遍类型. 更特定的元素类型支持更细粒度的优化, 元素类型在越靠右下，对该数组的操作可能就越慢. 为了获得最佳性能, 避免不必要地转换到那些普遍类型, 坚持使用最适合情况的特定类型.</p>
<p><img src="https://edge.yancey.app/beg/0t8gs8apw3-1621848252686.jpg" alt="elements kind 转化关系"></p>
<h2 id="performance-tips">Performance tips</h2>
<p>在大多数情况下我们无需 care 这种细微的类型转换. 但是, 你可以做以下几件事来获得最大的性能.</p>
<h3 id="avoid-reading-beyond-the-length-of-the-array">Avoid reading beyond the length of the array</h3>
<p>这个很好理解, 比如一个数组 arr 的长度是 5, 但你却访问了 <code>arr[42]</code>, 因为该数组没有一个叫做 42 的属性, 因此 JavaScript 引擎必须得到原型链上查找, 直到原型链的顶端 null 为止. 一旦负载遇到这种情况, V8 就会记住&quot;此负载需要处理特殊情况&quot;, 并且它再也不会像读取越界之前那样快.</p>
<p>下面这个例子, 在读取完数组中的所有元素后, 仍再读取一个越界的元素, 才跳出循环. 可能看到这段代码你会嗤之以鼻, 因为我们几乎 100% 不会这么写, 但 jQuery 里面极少代码就用到了这种模式.</p>
<pre><code class="language-ts">for (let i = 0, item; (item = items[i]) != null; i++) {
  doSomething(item);
}
</code></pre>
<p>取而代之, 我们用最朴素的 for 循环就够了.</p>
<pre><code class="language-ts">const n = items.length;
for (let index = 0; index &lt; n; index += 1) {
  const item = items[index];
  doSomething(item);
}
</code></pre>
<p>下面是原作者真实测量过的例子, 该方法传入 10000 个元素的数组, <code>i &lt;= array.length</code> 要比 <code>i &lt; array.length</code> 慢 6 倍(然而我测了好几遍下面的代码居然还快不少, 手动狗头).</p>
<pre><code class="language-ts">function Maximum(array) {
  let max = 0;
  for (let i = 0; i &lt;= array.length; i++) {
    // BAD COMPARISON!
    if (array[i] &gt; max) max = array[i];
  }
  return max;
}
</code></pre>
<p>最后, 如果你的集合是可迭代的, 比如 NodeList, Map, Set, 使用 for...of 也是不错的选择. 而对于数组, 可以使用 forEach 等内建原型方法. 如今, 无论是 for...of 还是 forEach, 它们的性能跟传统的 for 循环已经不相上下了.</p>
<p>稍微扩展一下, Airbnb 的规则 <a href="https://eslint.org/docs/rules/no-restricted-syntax">no-restricted-syntax</a> 屏蔽了 for...of, 理由如下. 不过我觉得 for...of 还是可以正常用, for...in 注意增加个 <code>hasOwnProperty</code> 限制就行.</p>
<blockquote>
<p>iterators/generators require regenerator-runtime, which is too heavyweight for this guide to allow them. Separately, loops should be avoided in favor of array iterations.</p>
</blockquote>
<h3 id="avoid-elements-kind-transitions">Avoid elements kind transitions</h3>
<p>上面就讲到了尽量不要进行 elements kind 的转换, 因为一旦转换了就是不可逆的. 这里有一些小知识, 尽管大家几乎 100% 不会做, 还是贴一下. 如 NaN, Infinity, -0 都会导致纯 Int 类型的数组变成 <code>PACKED_DOUBLE_ELEMENTS</code>.</p>
<pre><code class="language-ts">const arr = [1, 2, 3, +0]; // PACKED_SMI_ELEMENTS

arr.push(NaN, Infinity, -0); // PACKED_DOUBLE_ELEMENTS
</code></pre>
<h3 id="prefer-arrays-over-array-like-objects">Prefer arrays over array-like objects</h3>
<p>一些在 JavaScript 中的对象 —— 尤其在 DOM 中, 有很多的类数组对象, 有时你自己也会创建类数组对象(嗯, 只在面试中见过).</p>
<pre><code class="language-ts">const arrayLike = {};
arrayLike[0] = &quot;a&quot;;
arrayLike[1] = &quot;b&quot;;
arrayLike[2] = &quot;c&quot;;
arrayLike.length = 3;
</code></pre>
<p>上面的代码虽然有 index, 也有 length, 但它毕竟缺少真正数组的原型方法, 即便如此, 你也可以通过 call 或者 apply 数组的语法来使用它.</p>
<pre><code class="language-ts">Array.prototype.forEach.call(arrayLike, (value, index) =&gt; {
  console.log(`${index}: ${value}`);
});
// This logs &#39;0: a&#39;, then &#39;1: b&#39;, and finally &#39;2: c&#39;.
</code></pre>
<p>这段代码使用起来没啥问题, 但它仍然比真正的数组去调用 forEach 要慢, 因此如果有必要(比如要对该类数组进行大量的操作), 你可以先将该类数组对象转换为真正的数组, 再去做后续的操作, 也许这种牺牲空间换时间的方法是值得的.</p>
<pre><code class="language-ts">const actualArray = Array.prototype.slice.call(arrayLike, 0); // 先转换为真正的数组

actualArray.forEach((value, index) =&gt; {
  console.log(`${index}: ${value}`);
});
// This logs &#39;0: a&#39;, then &#39;1: b&#39;, and finally &#39;2: c&#39;.
</code></pre>
<p>另一个经典的的类数组是 argument, 和上面的例子一样, 同样可以通过 call 或者 apply 来使用数组的原型方法. 但随着 ES6 的普及, 我们更应该使用<strong>剩余参数</strong>, 因为剩余参数是真正的数组.</p>
<pre><code class="language-ts">const logArgs = (...args) =&gt; {
  args.forEach((value, index) =&gt; {
    console.log(`${index}: ${value}`);
  });
};
logArgs(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
</code></pre>
<h3 id="avoid-polymorphism">Avoid polymorphism</h3>
<p>如果你的一个方法会处理不同元素类型的数组, 它可能会导致多态操作, 这样会比操作单一元素类型的代码要慢. 举个例子来讲, 你自己写了个数组迭代器, 这个迭代器可以传入一个纯数字类型的数组, 也可以是其他乱七八糟类型的数组, 这样就是多态操作. 当然需要注意的是, 数组内建的原型方法在引擎内部已经做了优化, 不在我们的考虑范围.</p>
<p>下面这个例子中, each 方法先传入了 <code>PACKED_ELEMENTS</code> 类型的数组, 于是 V8 使用内联缓存(inline cache, 简称 IC) 来记住这个特定的类型. 此时 V8 会&quot;乐观的&quot;假定 <code>array.length</code> 和 <code>array[index]</code> 在 each 内部访问函数是<strong>单调的</strong>(即只有一种类型的元素). 因此如果后续传入该方法的数组仍是 <code>PACKED_ELEMENTS</code>, V8 可以复用这些先前生成的代码.</p>
<p>但在后面分别传入了 <code>PACKED_DOUBLE_ELEMENTS</code>, <code>PACKED_SMI_ELEMENTS</code> 类型的数组, 就会导致 <code>array.length</code> 和 <code>array[index]</code> 在 each 内部访问函数被标记为<strong>多态的</strong>. V8 在每次调用 each 时需要额外的检查一次 <code>PACKED_ELEMENTS</code>, 并添加一个新的 <code>PACKED_DOUBLE_ELEMENTS</code>, 这就会造成潜在的性能问题.</p>
<pre><code class="language-ts">const each = (array, callback) =&gt; {
  for (let index = 0; index &lt; array.length; ++index) {
    const item = array[index];
    callback(item);
  }
};
const doSomething = (item) =&gt; console.log(item);

each([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], doSomething); // PACKED_ELEMENTS

each([1.1, 2.2, 3.3], doSomething); // PACKED_DOUBLE_ELEMENTS

each([1, 2, 3], doSomething); // PACKED_SMI_ELEMENTS
</code></pre>
<h3 id="avoid-creating-holes">Avoid creating holes</h3>
<p>这条就对应着开头 React 源码的考量了, 直接看代码. 方式一你创建了数组长度为 3 的空数组, 那这个数组是<strong>稀疏</strong>的, 此时这个数组会被标记成 <code>HOLEY_SMI_ELEMENTS</code>, 即便最后我们填满了数组, 他也不会是 <code>packed</code> 的, 仍然被标记成是 <code>holey</code> 的. 方式二是最优雅的, 它被标记成了 <code>PACKED_ELEMENTS</code>. 当然如果你不知道到底有多少元素, 那么就使用方式三, 即将元素 push 到一个空数组将是最好的选择.</p>
<pre><code class="language-ts">// 方式 1 (不推荐)
const arr = new Array(3);
arr[0] = 0;
arr[1] = 1;
arr[2] = 2;

// 方式 2
const arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];

// 方式 3
const arr = [];
arr.push(0);
arr.push(1);
arr.push(2);
</code></pre>
<h2 id="最后">最后</h2>
<p>综上来讲, 这就是一篇爽文, 旨在涨涨见识. 基本百分之九十以上, 后端返回给我们的数组就已经是 <code>PACKED_ELEMENTS</code> 的类型了, 所以真正在乎这种内核级别优化的, 也就是如 React 这种牛逼的框架了. 当然还有一种情况, 我们似乎可以优化一番, 想想你刷动态规划的时候, 是不是初始化背包的时候就用了 <code>new Array(n).fill(false)</code> 这种代码呢? (手动狗头.</p>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2021-05-24T13:05:59.187Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[Daily Thoughts]]></title>
        <id>a49e2c26-18ef-47d9-a72a-1f4cd5070ad0</id>
        <link href="https://yanceyleo.com/post/a49e2c26-18ef-47d9-a72a-1f4cd5070ad0"/>
        <updated>2021-09-12T20:31:19.511Z</updated>
        <summary type="html"><![CDATA[开个空间写每日感想, 兴许比写 Tweet 有趣.]]></summary>
        <content type="html"><![CDATA[<h2 id="2021710">2021/7/10</h2>
<p>GitHub copilot 真无聊...</p>
<h2 id="2021708">2021/7/08</h2>
<p>好家伙, 我网站支持 HTTP/3 了.</p>
<p><img src="https://edge.yancey.app/beg/7trzmmwkx4-1625899559166" alt="HTTP/3"></p>
<h2 id="2021531">2021/5/31</h2>
<p>看到个段子挺有意思: &quot;治大国如调参, 今天改二, 明天改三, 能跑起来就行&quot;.</p>
<p><img src="https://edge.yancey.app/beg/3ltros194v-1622460197994" alt="3ltros194v-1622460197994"></p>
<h2 id="2021523">2021/5/23</h2>
<p>桂林玩了五天, 天天饭桌上都有臭了吧唧的菜.</p>
<p><img src="https://edge.yancey.app/beg/v1vhqjhdcg-1621824786296.jpg" alt="v1vhqjhdcg-1621824786296"></p>
<h2 id="2021517">2021/5/17</h2>
<p>Lane 模型比 expriationTime 好太多了.</p>
<h2 id="2021513">2021/5/13</h2>
<p>Google 也该学学人家某 du 整个主页皮肤. 🤔</p>
<p><img src="https://edge.yancey.app/beg/5rrz5bos7l-1620890630677" alt="skin"></p>
<h2 id="2021512">2021/5/12</h2>
<p>今儿看 React 源码看到了 FiberRoot 生成 <code>entanglements</code> 这块, 然而被 v8 那个链接给吸引住了.</p>
<pre><code class="language-ts">export function createLaneMap&lt;T&gt;(initial: T): LaneMap&lt;T&gt; {
  // Intentionally pushing one by one.
  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
  const laneMap = [];
  for (let i = 0; i &lt; TotalLanes; i++) {
    laneMap.push(initial);
  }
  return laneMap;
}
</code></pre>
<p>文章大抵来讲你就是创建数组, 并且填充元素可以有以下三种:</p>
<pre><code class="language-ts">// 方式 1
const arr = new Array(3)
arr[0] = 0
arr[1] = 1
arr[2] = 2

// 方式 2
const arr = [0, 1, 2]

// 方式 3
const arr = []
arr.push(0)
arr.push(1)
arr.push(2)
</code></pre>
<p>方式一你创建了数组长度为 3 的无元素数组, 那这个数组是<strong>稀疏</strong>的, 并且这三个位置会被标记成 <code>HOLEY_SMI_ELEMENTS</code>, 随着你填入数据, 它们会被标记成 <code>HOLEY_ELEMENTS</code>. 因此即便最后我们填满了数组, 但它仍然被标记成是 <code>holey</code> 的.</p>
<p>方式二是最优雅的, 它被标记成了 <code>PACKED_ELEMENTS</code>.</p>
<p>当然如果你不知道到底有多少元素, 那么就使用方式三, 即将元素 push 到一个空数组将是最好的选择.</p>
<p>想起前段时间刷题的时候经常 <code>new Array(n).fill(0)</code> 这种, 竟然是 v8 引擎不推荐的, 大开眼界.</p>
<h2 id="2021511">2021/5/11</h2>
<p>我觉得 React 的割裂点不在于状态管理库的选择, 而是 ClassComponent 和 FunctionComponent 之间的功能兼容. 自从 Hooks 出现, 关于状态管理, 确切说是 server cache, 更倾向于使用如下这种模式(可参考 relay, react-query, apoll-client 这几个库).</p>
<pre><code class="language-tsx"> const [getPosts, { data: posts, loading: isLoading }] = useLazyQuery&lt;
   PostQuery,
   PostVars
 &gt;(POSTS, {
   notifyOnNetworkStatusChange: true,
 })
</code></pre>
<p>而 ClassComponent 和 FunctionComponent 的割裂还是有些大, 比如前者有个 <code>Component.pure</code>, 后者就得适配个 <code>React.memo</code> 或者 <code>useMemo</code>. 而至今 <code>Error Boundaries</code> 还没有 Hooks 版, 意味着你在项目里多少得写个类组件.</p>
<h2 id="2021510">2021/5/10</h2>
<p>React.Children.map 这个 API 其实用的不多, 最初还是在 <a href="https://github.com/ant-design/ant-design/blob/master/components/button/button.tsx#L69">ant-design 的源码</a>里看到.</p>
<pre><code class="language-tsx">// Pass to React.Children.map to auto fill key
return React.Children.map(childList, child =&gt;
  insertSpace(child as React.ReactChild, needInserted),
);
</code></pre>
<p>回归到 ReactChildren 的源码中, 它简单来讲就是做了一坨递归, 因为 callback 里也可能是数组, 得把它展平. 有趣的是里面还设计了对象池的功能, 它是为了防止频繁创建 ReactNode 造成性能问题. 这种方式可以直接在对象池里拿现成的对象, 用完再去放回去. 其实这是一种典型的设计模式叫做<a href="https://en.wikipedia.org/wiki/Flyweight_pattern">享元模式(Flyweight Pattern)</a>. 一个典型的例子是地图上的 Tooltip, 你搜索加油站可能出现 10 个 tooltip, 你再搜索个别的, 就没必要重新创建 tooltip 实例了, 直接复用对象池里的, 多退少补. </p>
<p><img src="https://edge.yancey.app/beg/Jietu20210511-115954.jpg" alt="Flyweight Pattern"></p>
<p>看起来很装逼, 不过 Dan 把这坨代码给砍了, 我截图了这个 pr 的评论. 其实说白了, 就是这个 api 的需求量太小, 也一般没人让 callback 返回个数组, 纯属过度设计, 所以就给砍了. 关于最新版的这块源码, 我都写了<a href="https://github.com/learn-frame/react/blob/feature/learn-react/packages/react/src/ReactChildren.js">注释</a>, 可以看看.</p>
<p><img src="https://edge.yancey.app/beg/Jietu20210510-204112.jpg" alt="Dan 给 Children.map 的精简"></p>
<p>简简单单才是真.</p>
<p>以上.</p>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2021-05-10T12:39:30.670Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈 Server-Sent Events]]></title>
        <id>9804c55c-58df-4538-ac34-303f6395d446</id>
        <link href="https://yanceyleo.com/post/9804c55c-58df-4538-ac34-303f6395d446"/>
        <updated>2021-03-21T16:14:23.010Z</updated>
        <summary type="html"><![CDATA[前几天看到 Twitter 点赞区域蹦哒的很可爱, 于是乎想研究研究怎么实现的. 一开始下意识以为是 WebSocket, 但是在控制台死活没找到相关的信息, 去 stackoverflow 问了下原来是 Server-Sent Events, 本文对此做个介绍.]]></summary>
        <content type="html"><![CDATA[<p><img src="https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2010.45.19%20PM.png" alt="万能的推特"></p>
<h2 id="什么是-server-sent-events">什么是 Server-Sent Events</h2>
<p>Server-Sent Events 是一种服务器推送技术, 使客户端可以通过 <strong>HTTP 连接</strong>从服务器自动接收更新. 每个通知以<strong>文本流(文本应该为 utf-8)<strong>的形式发送, 并以一对</strong>换行符</strong>结尾. 与 WebSocket 相比:</p>
<ol>
<li>它不是全双工的, 只能服务器向浏览器发送, 因为流信息本质上就是下载, 一旦连接后不能再次发送请求(否则就变成了一次新的连接)</li>
<li>WebSocket 使用的 ws 协议, 而 SSE 使用的仍然是 HTTP 协议.</li>
</ol>
<h2 id="sse-的特点">SSE 的特点</h2>
<p>这里直接抄袭阮一峰聚聚的:</p>
<ul>
<li>SSE 使用 HTTP 协议, 现有的服务器软件都支持. WebSocket 是一个独立协议.</li>
<li>SSE 属于轻量级, 使用简单；WebSocket 协议相对复杂.</li>
<li>SSE 默认支持断线重连, WebSocket 需要自己实现.</li>
<li>SSE 一般只用来传送文本, 二进制数据需要编码后传送, WebSocket 默认支持传送二进制数据.</li>
<li>SSE 支持自定义发送的消息类型.</li>
</ul>
<h2 id="来个例子">来个例子</h2>
<p>无码言屌, 下面我们通过一个例子来演示怎么使用 SSE. 首先看客户端的代码, 通过 new 一个 EventSource 来创建 SSE 实例, 第一个参数为后端接口, 第二个 option 参数只有一个 <code>withCredentials</code>, 如果为 true, 在跨域的情况下, 可被允许发送 cookie.</p>
<pre><code class="language-ts">const evtSource = new EventSource(&quot;http://localhost:3002/sse&quot;, {
  withCredentials: true,
});
</code></pre>
<p>EventSource 可以监听三种事件, 分别是 <code>onopen</code>, <code>onmessage</code>, <code>onerror</code>, 第一个和第三个不用多说, 分别是<strong>建立连接成功</strong>和<strong>建立连接失败</strong>(CORS 或者请求超时等等). 而 <code>onmessage</code> 最重要, 它用来监听每次推送的信息流.</p>
<p>因为 SSE 接收的只能是 utf-8 的纯文本, 因此最通用的做法是后端传递一个 <strong>JSON 字符串</strong>. 下面的代码中, 每次接收到新的推送, 就会打印出 like_count, 直到 like_count &gt; 10, 客户端会主动要求服务端停止推送.</p>
<pre><code class="language-ts">interface Data {
  payload: { like_count: number };
}

evtSource.addEventListener(&quot;message&quot;, (e: MessageEvent) =&gt; {
  const {
    payload: { like_count },
  }: Data = JSON.parse(e.data);

  console.log(like_count);

  if (like_count &gt; 10) {
    evtSource.close();
  }
});
</code></pre>
<p>上面基本就是客户端要做的事情了, 很简单, 下面看下服务端的. 因为 nestjs 封装了对 SSE 的支持, 这里就用这个框架搞下.</p>
<p>事件流仅仅是一个简单的文本数据流, 文本应该使用 UTF-8 格式的编码. 每条消息后面都由一个空行作为分隔符. 每条消息是由多个字段组成的, 每个字段由<strong>字段名, 一个冒号, 以及字段值组成</strong>.</p>
<p>规范中支持四个字段, 分别是:</p>
<ul>
<li><p>event: 该字段为 onmessage 的子集, 也就是说你可以通过 <code>evtSource.addEventListener(&quot;customEvt&quot;, () =&gt; {}</code> 来细粒度监听指定 event 的推送.</p>
</li>
<li><p>data: 也就是传递的实体, 如果该条消息包含多个 data 字段, 则客户端会用换行符把它们连接成一个字符串来作为字段值.</p>
</li>
<li><p>id 可以给每次推送增加一个 id 标识, 比如是 tweetId, 这样就可以把实体中的 likeCount 跟 tweetId 一一映射.</p>
</li>
<li><p>retry: 指定浏览器重新发起连接的时间间隔, 它是一个整数值, 指定了重新连接的时间(单位为毫秒), 如果不是正整数将被忽略</p>
</li>
</ul>
<p>此外, 以冒号开头的行为注释行, 会被忽略, 注释行可以用来防止连接超时, 服务器可以定期发送一条消息注释行, 以保持连接不断.</p>
<pre><code class="language-ts">: just a comment\n\n

id: 12345\n
event: addLikeCount\n
retry: 10000\n
data: {\n
data: &quot;likeCount&quot;: 1,\n
data: }\n\n
</code></pre>
<p>下面直接看后端代码实现, 由于 nestjs 实现 SSE 必须用 rxjs, 所以得有点儿相关基础. 代码中每两秒吐出一次数据, 由于 nestjs 会将 data 转化为 SSE 想要的结构, data 直接写成对象即可.</p>
<pre><code class="language-ts">import { Injectable } from &quot;@nestjs/common&quot;;
import { interval } from &quot;rxjs&quot;;
import { map } from &quot;rxjs/operators&quot;;
import { randomSeries } from &quot;yancey-js-util&quot;;

@Injectable()
export class SSEService {
  public sse() {
    let count = 1;
    return interval(2000).pipe(
      map((_) =&gt; ({
        id: randomSeries(6),
        type: &quot;addLikeCount&quot;,
        data: { payload: { tweetId: randomSeries(6), likeCount: count++ } },
        retry: 10000,
      }))
    );
  }
}
</code></pre>
<p>如果没什么意外, 前端就可以看到 stream 了.</p>
<p><img src="https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2011.36.29%20PM.png" alt="相应体"></p>
<p>分析下响应头, 很重要的两个标志是禁止了缓存, 并且 <code>Content-Type: text/event-stream</code>.</p>
<p><img src="https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2011.37.55%20PM.png" alt="响应头"></p>
<h2 id="graphql-是否支持">GraphQL 是否支持?</h2>
<p><img src="https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2011.49.43%20PM.png" alt="GraphQL 是否支持?"></p>
<p>Emmmm, 似乎不支持, 不过 GraphQL 本身已经有了强大的 Subscriptions 系统, 也没必要支持这些玩意儿了(毕竟去年 GraphQL 支持个上传还不利索, 逃).</p>
<h2 id="can-i-use-sse">Can I use SSE?</h2>
<p>Emmmm, 除了某浏览器, 都可以用.</p>
<p><img src="https://edge.yancey.app/beg/Screen%20Shot%202021-03-21%20at%2010.40.10%20PM.png" alt="can i use?"></p>
<h2 id="其他">其他</h2>
<p>突然想到, 我在后端配置了 rateLimit. 那么前端如此频繁的获取数据, 会触发 rateLimit 吗? 答案是不会的, 因为 SSE 始终只是一条 HTTP 请求, 而 rateLimit 限制的只是重复请求.</p>
<pre><code class="language-ts">app.use(
  rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
  })
);
</code></pre>
<h2 id="奉上全部代码">奉上全部代码</h2>
<pre><code class="language-ts">// 前端部分

// SSE.tsx
import { FC, useState, useEffect } from &quot;react&quot;;

interface CustomEvent extends Event {
  data: string;
}

interface Data {
  payload: {
    likeCount: number;
  };
}

const SSE: FC = () =&gt; {
  const [like, setLike] = useState(0);

  const initialSSE = () =&gt; {
    const evtSource = new EventSource(&quot;http://localhost:3002/sse&quot;, {
      withCredentials: true,
    });

    evtSource.addEventListener(&quot;open&quot;, () =&gt; {
      console.log(&quot;已开启&quot;);
    });

    // 这里使用的便是自定义事件
    evtSource.addEventListener(&quot;addLikeCount&quot;, ((e: CustomEvent) =&gt; {
      const {
        payload: { likeCount },
      }: Data = JSON.parse(e.data);

      setLike(likeCount);

      if (likeCount &gt; 10) {
        evtSource.close();
      }
    }) as EventListener);

    evtSource.addEventListener(&quot;message&quot;, (e: MessageEvent) =&gt; {});

    evtSource.addEventListener(&quot;error&quot;, (err: Event) =&gt; {
      console.log(err);
    });
  };

  useEffect(() =&gt; {
    initialSSE();
  }, []);

  return &lt;div&gt;{like}&lt;/div&gt;;
};

export default SSE;

// 后端部分

// sse.module.ts
import { Module } from &quot;@nestjs/common&quot;;
import { SSEController } from &quot;./sse.controller&quot;;
import { SSEService } from &quot;./sse.service&quot;;

@Module({
  controllers: [SSEController],
  providers: [SSEService],
})
export class SSEModule {}

// sse.controller.ts
import { Controller, MessageEvent, Sse } from &quot;@nestjs/common&quot;;
import { Observable } from &quot;rxjs&quot;;
import { SSEService } from &quot;./sse.service&quot;;

@Controller()
export class SSEController {
  constructor(private readonly sseService: SSEService) {
    this.sseService = sseService;
  }

  @Sse(&quot;sse&quot;)
  public sse(): Observable&lt;MessageEvent&gt; {
    return this.sseService.sse();
  }
}

// sse.service.ts
import { Injectable } from &quot;@nestjs/common&quot;;
import { interval } from &quot;rxjs&quot;;
import { map } from &quot;rxjs/operators&quot;;
import { randomSeries } from &quot;yancey-js-util&quot;;

@Injectable()
export class SSEService {
  public sse() {
    let count = 1;
    return interval(2000).pipe(
      map((_) =&gt; ({
        id: randomSeries(6),
        type: &quot;addLikeCount&quot;,
        data: { payload: { tweetId: randomSeries(6), likeCount: count++ } },
        retry: 10000,
      }))
    );
  }
}
</code></pre>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format">Using server-sent events</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2017/05/server-sent_events.html">Server-Sent Events 教程</a></li>
</ul>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2021-03-21T15:52:57.272Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[手摸手教你 360 度无死角 WebP 能力检测]]></title>
        <id>4f36126a-2104-49e0-bf8c-270c16d7be78</id>
        <link href="https://yanceyleo.com/post/4f36126a-2104-49e0-bf8c-270c16d7be78"/>
        <updated>2021-10-11T07:25:40.283Z</updated>
        <summary type="html"><![CDATA[WebP 作为当今性价比最高的图片格式之一, 广泛应用于 Web 应用, 无论是电商网站还是图片流网站, 都能看到它的身影. 但它仍不被某些浏览器所支持, 这篇文章通过三种方案, 帮你全方位扫清 WebP 能力检测.]]></summary>
        <content type="html"><![CDATA[<h2 id="什么是-webp">什么是 WebP</h2>
<p>WebP 是 Google 开发一种同时采用有损和无损压缩的图像格式,于 2010 年 9 月 30 日首次发布, 可用于网页上大量摄影, 半透明和图形图像. WebP 有损压缩的程度是可调的, 因此用户可以在文件大小和图像质量之间自由权衡. WebP 通常平均比 JPEG 和 JPEG 2000 多压缩 30%, 而且不会损失图像质量. 关于 WebP 格式的压缩实验, 可参考 <a href="https://www.zhihu.com/question/27201061/answer/35637827">WebP 相对于 PNG、JPG 有什么优势？ - Hahn 的回答 - 知乎</a> 的回答, 这篇文章不做赘述.</p>
<p>WebP 除了有损和无损形式, 它还支持 Alpha 通道(图像可能具有透明度), 也支持 Animation(即动图, 可类比 GIF). 目前 Youtube 在支持 WebP 格式的浏览器中, 将<strong>视频预览</strong>的图像格式全部转换为 WebP; 而不支持 WebP 的浏览器如 Safari, Youtube 干脆就取消了<strong>视频预览</strong>的特性.</p>
<p><img src="https://edge.yancey.app/beg/Jietu20200721-135252.jpg" alt="Youtube 预览使用 WebP 格式"></p>
<p>WebP 已诞生 10 年之久, 并且对于图片性能的提升肉眼可见, 但部分浏览器仍不支持. 下面是 <a href="https://caniuse.com/#search=WebP">caniuse</a> 给出的数据, 可见 <del>IE</del> 和苹果系的浏览器仍不支持, 这里可能是一些技术原因, 但更多是商业因素. 因此这篇文章教你 360° 无死角 WebP 的能力检测.</p>
<p><img src="https://edge.yancey.app/beg/Jietu20200720-202312.jpg" alt="Can I use WebP?"></p>
<h2 id="方案一">方案一</h2>
<p>方案一通过 JavaScript 脚本进行检测, 这里用到了 <a href="https://modernizr.com/">Modernizr</a>, 该库提供了大量浏览器能力检测的脚本. 我已经把 WebP 能力检测的脚本放到了 gist, 你可访问 <a href="https://gist.github.com/YanceyOfficial/5951b17d7a64906248ecb7a8074791c1">WebP 能力检测.js</a> 下载.</p>
<p>在浏览器中执行这段脚本, 最新版的 Chrome 浏览器给 html 标签增加了 <code>webp</code>, <code>webp-alpha</code>, <code>webp-aniamtion</code>, <code>webp-lossless</code> 的类; 而 Safari 浏览器增加了 <code>no-webp</code> 的类, 因此我们在 css 中, 只要写出形如下的代码就可以了.</p>
<p><img src="https://edge.yancey.app/beg/Jietu20200721-112534.jpg" alt="支持 WebP"></p>
<p><img src="https://edge.yancey.app/beg/Jietu20200721-112156.jpg" alt="不支持 WebP"></p>
<pre><code class="language-css">.no-webp .cover {
  background-image: url(&#39;image.jpg&#39;);
}

.webp .cover {
  background-image: url(&#39;image.webp&#39;);
}
</code></pre>
<p>当然如果用到 img 标签上, 你还可以这么写.</p>
<pre><code class="language-jsx">const [supportWebP, setSupportWebP] = useState(
  document.documentElement.classList.contains(&#39;webp&#39;),
)

return &lt;img src={supportWebP ? &#39;image.webp&#39; : &#39;image.jpg&#39;} alt=&quot;img&quot; /&gt;
</code></pre>
<p>Modernizr 给出的脚本做了较多的兼容, minify 后也有 1.2kb 的大小, 下面这段代码比较精简, 根据实际情况可以考虑使用. 它返回一个 Boolean 类型, 你可以把结果存到 Store 或者 LocalStorage 中, 也可以跟 Modernizr 一样, 给 html 的 class 增加一个 webp 标识. 这段代码收集到了我的工具集 <a href="https://www.npmjs.com/package/yancey-js-util">yancey-js-util</a>, 有兴趣也可使用 <code>yarn add yancey-js-util</code> 安装使用.</p>
<pre><code class="language-ts">export const checkWebp = () =&gt; {
  return (
    document
      .createElement(&#39;canvas&#39;)
      .toDataURL(&#39;image/webp&#39;)
      .indexOf(&#39;data:image/webp&#39;) === 0
  )
}
</code></pre>
<h2 id="方案二">方案二</h2>
<p>第二种方式是使用 HTML5 新增的 <strong>picture</strong> 标签. 与 <strong>audio</strong>, <strong>video</strong> 标签类似, 它们都可以包含 <strong>source</strong> 标签, 用于让浏览器自行选择最优的格式来呈现. 这种方案无需 js 代码, 性能会更好一些, 但它的缺点显而易见, 即无法应用于 css 的 background-image.</p>
<pre><code class="language-tsx">&lt;picture&gt;
  &lt;source srcset=&quot;img/image.webp&quot; type=&quot;image/webp&quot; /&gt;
  &lt;source srcset=&quot;img/image.jpg&quot; type=&quot;image/jpeg&quot; /&gt;
  &lt;img src=&quot;img/image.jpg&quot; alt=&quot;img&quot; /&gt;
&lt;/picture&gt;
</code></pre>
<h2 id="方案三">方案三</h2>
<p>方案一可以应用于 <strong>backgroud-image</strong> 和 <strong>img</strong> 标签两种场景, 似乎是一种万全之策, 但它毕竟依托于 JavaScript. 如果用户阻止浏览器使用 JS 脚本, 或者说在 SSR 服务端渲染阶段(因为这些检测脚本涉及到了 DOM 操作, 而服务端是无法操作 DOM 的), 方案一就不 ok 了.</p>
<p>第一种情况比较极端, 我们可以一开始就给 html 标记上 <code>no-js</code> 的 class, 当 DOM 加载完成后执行如下脚本, 如果 no-js 被移除了, 那证明 JS 没有被阻止; 否则降级处理, 代码如下所示.</p>
<pre><code class="language-tsx">&lt;style&gt;
  .no-js .elementWithBackgroundImage {
    background-image: url(&#39;image.jpg&#39;);
  }
&lt;/style&gt;

&lt;script&gt;
  document.documentElement.classList.remove(&#39;no-js&#39;)
&lt;/script&gt;
</code></pre>
<p>对于 SSR 场景下, 方案二可保证所有的 img 标签都能展示最优结果, 但对于 background-image 就无能为力了. 这种情况下, 我们依然可以借助后端之力. 在 HTTP 请求头中的 accept 字段中, 我们发现了 <code>image/webp</code> 的字样, 后端接收到这个请求, 只要判断存在 <code>image/webp</code>, 就证明该浏览器支持 WebP 格式, 后端将<strong>你的浏览器支持 WebP</strong> 再告诉给前端, 那这个问题就迎刃而解了.</p>
<p><img src="https://edge.yancey.app/beg/Jietu20200721-153247.jpg" alt="HTTP 请求头中记录浏览器是否支持 WebP"></p>
<p>下面这段代码是<a href="https://yanceyleo.com">我的博客</a>中的真实案例, 项目使用了 <a href="https://nextjs.org">Next.js</a> 做服务端渲染, 通过 <code>getServerSideProps</code> 方法将 <code>isSupportWebp</code> 返回给前端, 进而前端判断是否有能力展示 WebP 格式的图片.</p>
<pre><code class="language-tsx">import React, { FC } from &#39;react&#39;
import { GetServerSidePropsContext } from &#39;next&#39;
import Layout from &#39;src/containers/Layout/Layout&#39;
import HomeContainer from &#39;src/containers/Home/Home&#39;

interface Props {
  isSupportWebp: boolean
}

// 前端以 props 的形式获取该浏览器是否支持 WebP
const Index: FC&lt;Props&gt; = ({ isSupportWebp }) =&gt; {
  return (
    &lt;Layout&gt;
      &lt;HomeContainer isSupportWebp={isSupportWebp} /&gt;
    &lt;/Layout&gt;
  )
}

// 后端判断该浏览器是否支持 WebP
export const getServerSideProps = async (ctx: GetServerSidePropsContext) =&gt; {
  return {
    props: {
      isSupportWebp: ctx.req.headers.accept?.includes(&#39;image/webp&#39;),
    },
  }
}

export default Index
</code></pre>
<h2 id="小结">小结</h2>
<p>Emmmm, 没啥可小结的, 还是希望各位浏览器大大们早日统一吧.</p>
<h2 id="参考">参考</h2>
<ul>
<li><p><a href="https://css-tricks.com/using-webp-images/">Using WebP Images</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/27201061">WebP 相对于 PNG、JPG 有什么优势？</a></p>
</li>
<li><p><a href="https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html">探究 WebP 一些事儿</a></p>
</li>
</ul>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2020-07-21T08:20:10.783Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[聊一聊 ES6 的 Proxy 与 Reflect]]></title>
        <id>59bfb250-4b87-4ea4-83d5-c9458ef9e4ac</id>
        <link href="https://yanceyleo.com/post/59bfb250-4b87-4ea4-83d5-c9458ef9e4ac"/>
        <updated>2021-07-05T03:47:52.159Z</updated>
        <summary type="html"><![CDATA[ES5 和 ES6 致力为开发者提供 JavaScript 已有却不可调用的功能. 例如 ES5 出现的 Object.defineProperty() 使操作对象是否可枚举, 是否可写等等成为可能. 而 Proxy 和 Reflect 比 Object.defineProperty() 更加先进和高效, 知名的 Vue 3.x 将使用代理重写, 拿奖到手软的 immer 也是通过 Proxy 实现...]]></summary>
        <content type="html"><![CDATA[<h2 id="objectdefineproperty-的局限性">Object.defineProperty() 的局限性</h2>
<p>谈到 Proxy 就不得不提起它的大前辈 Object.defineProperty(), 我们都知道早期的 Vue 无法监听数组如 <code>push</code>, <code>splice</code> 等操作, 这是因为 Vue 内核使用了 <a href="../Object/defineProperty">Object.defineProperty()</a>, 它虽然能劫持数组并为其设置 getter 和 setter, 但调用 <code>push</code>, <code>splice</code> 等操作时却无法触发 setter, 虽然尤小右同学<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/array.js">重写了这些方法</a>, 但总有如鲠在喉的感觉.</p>
<p>而万众瞩目的 Vue 3.x 将使用 Proxy 重写内核, 最近拿奖拿到手软 <a href="https://immerjs.github.io/immer/docs/introduction">immer.js</a> 同样是用 Proxy 编写. 当然无论是 Object.defineProperty() 还是 Proxy, 它们都是为了使“元编程”变为可能. 在深入 Proxy 之前, 首先聊一聊 Object.defineProperty() 的局限性.</p>
<p><img src="https://edge.yancey.app/beg/proxyVSdefineProperty.jpeg" alt="proxyVSdefineProperty.jpeg"></p>
<h3 id="拦截方式较少">拦截方式较少</h3>
<p>相比较 Proxy 的 13 种陷阱, Object.defineProperty() 只能对如下属性操作符进行修改.</p>
<pre><code class="language-ts">interface PropertyDescriptor {
  configurable?: boolean
  enumerable?: boolean
  value?: any
  writable?: boolean
  get?(): any
  set?(v: any): void
}
</code></pre>
<h3 id="无法一次性监听对象的所有属性">无法一次性监听对象的所有属性</h3>
<p>Object.defineProperty() 只能通过遍历(或递归)的方式处理对象中的每个属性, 而 Proxy 直接代理整个对象.</p>
<pre><code class="language-ts">const obj = {
  name: &#39;Yancey&#39;,
  age: 18,
}

Object.keys(obj).forEach((key) =&gt; {
  Object.defineProperty(obj, key, {
    enumerable: false,
  })
})
</code></pre>
<h3 id="无法监听新增属性">无法监听新增属性</h3>
<p>上面的代码仅仅是对 <code>name</code> 和 <code>age</code> 做了不可枚举的处理, 如果新增一个属性, 它仍然是可以枚举的, 如果你写过 Vue, 相信你对 <code>Vue.set()</code> 一定不陌生.</p>
<pre><code class="language-ts">obj.hobby = &#39;eat&#39;
console.log(obj.propertyIsEnumerable(&#39;hobby&#39;)) // true
</code></pre>
<h3 id="无法监听-push-splice-等数组方法">无法监听 push, splice 等数组方法</h3>
<p>上面已经谈到了原因, 这里不再赘述, Vue 通过重写这些原型方法来达到可监听的目的:</p>
<pre><code class="language-ts">import { def } from &#39;../util/index&#39;

const arrayProto = Array.prototype
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  &#39;push&#39;,
  &#39;pop&#39;,
  &#39;shift&#39;,
  &#39;unshift&#39;,
  &#39;splice&#39;,
  &#39;sort&#39;,
  &#39;reverse&#39;,
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  def(arrayMethods, method, function mutator(...args) {
    const result = original.apply(this, args)
    const ob = this.__ob__
    let inserted
    switch (method) {
      case &#39;push&#39;:
      case &#39;unshift&#39;:
        inserted = args
        break
      case &#39;splice&#39;:
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    return result
  })
})
</code></pre>
<h3 id="兼容性">兼容性</h3>
<p>除了万恶的 IE 和早期浏览器, Proxy 都可以在项目中完美使用, 而 Object.defineProperty() 出自 ES5, 几乎现存浏览器都可以使用. 很多库也给出了兼容方案, 即高级浏览器使用 Proxy, 低级浏览器回退为 Object.defineProperty().</p>
<h2 id="什么是代理和反射">什么是代理和反射</h2>
<p><code>Proxy</code> 就是在访问或操作目标对象之前架设一个拦截对象, 使得 <code>Proxy</code> 对象可自定义基本操作的某些行为（如属性查找、赋值、枚举、函数调用等, <code>Proxy</code> 接受两个参数, 第一个是<strong>目标对象</strong>, 第二个是<strong>陷阱函数</strong>.</p>
<p><code>Reflect</code> 提供拦截 JavaScript 操作的原生方法, 每个代理陷阱函数都有一个对应的反射方法, 每个方法都与对应的陷阱函数同名, 并且接收的参数也与之一致.</p>
<p>:::caution
与大多数全局对象不同, Reflect 不是一个构造函数, 因此不能将其与一个 new 运算符一起使用(类似的还有 Math).
:::</p>
<table>
<thead>
<tr>
<th>代理陷阱</th>
<th>被重写的行为</th>
<th>默认行为</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>读取一个属性值</td>
<td>Reflect.get()</td>
</tr>
<tr>
<td>set</td>
<td>写入一个属性</td>
<td>Reflect.set()</td>
</tr>
<tr>
<td>has</td>
<td>in 操作符</td>
<td>Reflect.has()</td>
</tr>
<tr>
<td>deleteProperty</td>
<td>delete 操作符</td>
<td>Reflect.deleteProperty()</td>
</tr>
<tr>
<td>getPropertyOf</td>
<td>Object.getPropertyOf()</td>
<td>Reflect.getPropertyOf()</td>
</tr>
<tr>
<td>setPropertyOf</td>
<td>Object.setPropertyOf()</td>
<td>Reflect.setPropertyOf()</td>
</tr>
<tr>
<td>isExtensible</td>
<td>Object.isExtensible()</td>
<td>Reflect.isExtensible()</td>
</tr>
<tr>
<td>preventExtensions</td>
<td>Object.preventExtensions()</td>
<td>Reflect.preventExtensions()</td>
</tr>
<tr>
<td>getOwnPropertyDesciptor</td>
<td>Object.getOwnPropertyDesciptor()</td>
<td>Reflect.getOwnPropertyDesciptor()</td>
</tr>
<tr>
<td>defineProperty</td>
<td>Object.defineProperty()</td>
<td>Reflect.defineProperty()</td>
</tr>
<tr>
<td>ownKeys</td>
<td>Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.assign()</td>
<td>Reflect.ownKeys()</td>
</tr>
<tr>
<td>apply</td>
<td>调用一个函数</td>
<td>Reflect.apply()</td>
</tr>
<tr>
<td>construct</td>
<td>用 new 调用一个函数</td>
<td>Reflect.construct()</td>
</tr>
</tbody></table>
<h2 id="小试牛刀">小试牛刀</h2>
<p>下面的例子中, 给 target 对象创建一个代理对象 proxy, 当 proxy.name 被赋值时, target.name 也同时被创建; 同样地, 当修改 target 时, proxy 也会反映出相应的变化.</p>
<p>:::tip
需要注意的是, 代理对象 proxy 自身并不存储 name, 它只是简单的将值转发给 target 对象.
:::</p>
<pre><code class="language-ts">const target = {}

const proxy = new Proxy(target, {})

proxy.name = &#39;proxy&#39;
console.log(proxy.name) // proxy
console.log(target.name) // proxy

target.name = &#39;target&#39;
console.log(proxy.name) // target
console.log(target.name) // target
</code></pre>
<h2 id="使用-set-陷阱函数验证属性值">使用 set 陷阱函数验证属性值</h2>
<p>Proxy 更强大的地方在于它的第二个参数, 也就是<strong>陷阱函数</strong>. 接下来通过一个 set 陷阱验证属性值的例子来学习: 假设有一个对象, 该对象已经存在的属性的属性值可以是任意类型, 但新增的属性的属性值必须是 Number 类型, 否则将抛出错误. 直接上代码:</p>
<pre><code class="language-ts">const validationSchema = {
  name: {
    validate(value) {
      return value.length &gt; 6
    },
    message: &#39;用户名长度不能小于6&#39;,
  },
  password: {
    validate(value) {
      return value.length &gt; 10
    },
    message: &#39;密码长度不能小于10&#39;,
  },
  moblie: {
    validate(value) {
      return /^1\d{10}$/.test(value)
    },
    message: &#39;手机号格式错误&#39;,
  },
}

function validator(obj, validationSchema) {
  return new Proxy(obj, {
    set(trapTarget, key, value) {
      const validator = validationSchema[key]
      if (!validator) {
        trapTarget[key] = value
      } else if (validator.validate(value)) {
        trapTarget[key] = value
      } else {
        console.log(validator.message || &#39;&#39;)
      }
    },
  })
}

const form = validator(form, validationSchema)
form.name = &#39;666&#39; // 报错
form.password = &#39;113123123123123&#39;
</code></pre>
<p>上面的例子中, 需要在<strong>写入</strong>对象时做一些拦截, 因此需要代理对象的 <code>set</code>, set 陷阱接收四个参数, 分别是:</p>
<ul>
<li><p>trapTarget: 将接收属性的对象, 即目标对象</p>
</li>
<li><p>key: 需要写入的属性 (key 为 String 或 Symbol 类型)</p>
</li>
<li><p>value: 需要写入的属性的属性值</p>
</li>
<li><p>receiver: 操作发生的对象, 一般为代理对象</p>
</li>
</ul>
<p>:::tip
这个例子似乎有了表单校验的雏形. 此外, 还可以使用 get 陷阱函数进行对象外形验证, 使用 has 陷阱函数隐藏属性, 使用 deleteProperty 陷阱函数避免属性被删除.
:::</p>
<h2 id="原型代理">原型代理</h2>
<p>ES6 新增了两个对象方法, 分别是 <a href="../Object/getPrototypeOf">Object.getPrototypeOf()</a> 和 <a href="../Object/setPrototypeOf">Object.setPrototypeOf()</a>, 以代替大多数浏览器厂商自行约定的属性 <code>__proto__</code></p>
<p>我们知道, 一个对象的原型, 要么是一个对象, 要么到达原型链的终点, 也就是 null, 其他任何类型都会返回运行时的错误; setPrototypeOf 必须在操作没有成功的情况下返回 false, 这样会让 Object.setPrototypeOf() 抛出错误, 否则认为成功.</p>
<p>对于 getPrototypeOf, 它的陷阱函数接受一个参数:</p>
<ul>
<li>trapTarget: 需要设置原型的对象(即代理的目标对象)</li>
</ul>
<p>对于 setPrototypeOf, 它的陷阱函数接受两个参数:</p>
<ul>
<li><p>trapTarget: 需要设置原型的对象(即代理的目标对象)</p>
</li>
<li><p>proto: 需用被用作原型的对象</p>
</li>
</ul>
<p>下面的例子通过返回 null 隐藏了代理对象的原型, 并且使得该原型不可被修改.</p>
<pre><code class="language-ts">let target = {}
let proxy = new Proxy(target, {
  getPrototypeOf(trapTarget) {
    return null
  },
  setPrototypeOf(trapTarget, proto) {
    return false
  },
})

let targetProto = Object.getPrototypeOf(target)
let proxyProto = Object.getPrototypeOf(proxy)

console.log(targetProto === Object.prototype) // true
console.log(proxyProto === Object.prototype) // false
console.log(proxyProto) // null

Object.setPrototypeOf(target, {}) // 成功
Object.setPrototypeOf(proxy, {}) // 抛出异常
</code></pre>
<p>与这两个陷阱对应的是 <code>Reflect.getPrototypeOf()</code> 和 <code>Reflect.setPrototypeOf()</code>, 这两个更加个底层, 操作的是 <code>[[GetPrototypeOf]]</code> 与 <code>[[SetPrototypeOf]]</code>, 而 <code>getPrototypeOf</code> 和 <code>setPrototypeOf</code> 显然是更高级的封装.</p>
<h2 id="对象可扩展性的陷阱函数">对象可扩展性的陷阱函数</h2>
<p>ES5 通过 <a href="../Object/preventExtensions">Object.preventExtensions()</a> 与 <a href="../Object/isExtensible">Object.isExtensible()</a> 来判断对象是否可扩展. 这里简单复习下: 前者用于禁止给对象及其原型<strong>添加新属性</strong>, 但不会影响已有属性的<strong>修改</strong>和<strong>删除</strong>; 后者则是判断一个对象是否可扩展.</p>
<p>下面的例子本身没有什么意义, 代理仍然返回了 isExtensible 与 preventExtensions 陷阱函数的默认行为. 同原型代理一样, 代理方法仍然要比高层的方法更加的底层, 它对传参的检查更加的严格.</p>
<pre><code class="language-ts">let target = {}
let proxy = new Proxy(target, {
  isExtensible(trapTarget) {
    return Reflect.isExtensible(trapTarget)
  },
  preventExtensions(trapTarget) {
    return Reflect.preventExtensions(trapTarget)
  },
})

console.log(Object.isExtensible(target)) // true
console.log(Object.isExtensible(proxy)) // true

Object.preventExtensions(proxy)

console.log(Object.isExtensible(target)) // false
console.log(Object.isExtensible(proxy)) // false
</code></pre>
<h2 id="属性描述符的陷阱函数">属性描述符的陷阱函数</h2>
<p>属性描述符的陷阱函数实际上是对 <a href="../Object/defineProperty">Object.defineProperty()</a> 和 <a href="../Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor()</a> 的代理, 它可以用来自定义创建属性描述符和查询属性描述符. 下面的例子中, 如果一个对象的 key 是 Symbol 类型, 那么不能为它设置属性描述符.</p>
<pre><code class="language-ts">let proxy = new Proxy(
  {},
  {
    defineProperty(trapTarget, key, descriptor) {
      if (typeof key === &#39;symbol&#39;) {
        return false
      }
      return Reflect.defineProperty(trapTarget, key, descriptor)
    },
  },
)
Object.defineProperty(proxy, &#39;name&#39;, { value: &#39;proxy&#39; })

console.log(proxy.name) // &#39;name&#39;

let nameSymbol = Symbol(&#39;name&#39;)
// 抛出错误
Object.defineProperty(proxy, nameSymbol, {
  value: &#39;proxy&#39;,
})
</code></pre>
<h2 id="ownkeys-陷阱函数">ownKeys 陷阱函数</h2>
<p>ownKeys 陷阱拦截了内部方法 <code>[[OwnPropertyKeys]]</code>, 它允许你返回一个数组用于重写该行为, 被重写的行为可以是 <a href="../Object/keys">Object.key()</a>、<a href="../Object/getOwnPropertyNames">Object.getOwnPropertyNames()</a>、<a href="../Object/getOwnPropertySymbols">Object.getOwnPropertySymbols()</a>、<a href="../Object/assign">Object.assign()</a>. 在 JS 编码习惯中, 一般约定将以<strong>下划线打头</strong>的属性视为私有属性, 下面的例子通过代理过滤掉所有的 “私有属性”:</p>
<pre><code class="language-ts">const proxy = new Proxy(
  {},
  {
    ownKeys(trapTarget) {
      return Reflect.ownKeys(trapTarget).filter((key) =&gt; {
        return typeof key !== &#39;string&#39; || key[0] !== &#39;_&#39;
      })
    },
  },
)

proxy.name = &#39;public property&#39;
proxy._name = &#39;private property&#39;
proxy.age = 18
proxy[Symbol(&#39;symbolName&#39;)] = &#39;symbol property&#39;

Object.defineProperty(proxy, &#39;age&#39;, {
  enumerable: false, // age 不可枚举
})

// 原生 Object.getOwnPropertyNames() 返回一个包括不可枚举属性, 不包括 Symbol 值作为名称的属性, 不会获取到原型链上的属性的数组.
// 通过代理后, 在原生的基础上过滤掉了私有属性 _name
console.log(Object.getOwnPropertyNames(proxy)) // [ &#39;name&#39;, &#39;age&#39; ]

// 原生 Object.keys() 返回一个不包括不可枚举属性, 不包括 Symbol 值作为名称的属性, 不会获取到原型链上的属性的数组.
// 通过代理后, 在原生的基础上过滤掉了私有属性 _name
console.log(Object.keys(proxy)) // [ &#39;name&#39; ]

// 原生 Object.getOwnPropertySymbols() 返回一个包括不可枚举 Symbol 的属性, 不包括普通字符串作为名称的属性, 不会获取到原型链上的 Symbol 属性的数组.
// 当然该方法不能直观的看出是否过滤了 _name, 但本质上该私有属性 _name 已经被过滤了!
console.log(Object.getOwnPropertySymbols(proxy)) // [ Symbol(symbolName) ]
</code></pre>
<p>:::tip
目前公认的定义私有属性的方式是以下划线打头, 此外也有使用 # 作为私有属性标识符的提案, 当然使用 WeakMap 定义私有变量也是一个可行的方案, 不过都不如 TypeScript 香啊.
:::</p>
<h2 id="使用-apply-与-construct-陷阱函数的函数代理">使用 apply 与 construct 陷阱函数的函数代理</h2>
<p>在所有的代理陷阱中, 只有 <code>apply</code> 和 <code>construct</code> 的代理目标必须是一个函数, 我们知道函数有两个内部方法 <code>[[Call]]</code> 和 <code>[[Construct]]</code>, 前者会在函数被直接调用时执行, 后者会在使用 new 的时候执行.</p>
<p>当不使用 new 调用一个函数时, apply 陷阱函数会接受以下三个参数:</p>
<ul>
<li><p>trapTarget: 被执行的函数(即代理的目标对象)</p>
</li>
<li><p>thisArg: 调用过程中函数内部的 this 值</p>
</li>
<li><p>argumentsList: 被传递给函数的参数数组</p>
</li>
</ul>
<p>当使用 new 创建构造函数的一个实例时, construct 陷阱函数会接受以下两个参数:</p>
<ul>
<li><p>trapTarget: 被执行的函数(即代理的目标对象)</p>
</li>
<li><p>argumentsList: 被传递给函数的参数数组</p>
</li>
</ul>
<p>Reflect.construct() 方法同样会接收到这两个参数, 还会收到可选的第三参数 newTarget, 如果提供了此参数, 则它就指定了函数内部的 <code>new.target</code> 值.</p>
<h3 id="验证函数参数的有效性">验证函数参数的有效性</h3>
<p>考虑以下函数, 我们需要限制传递的参数都是数字类型, 因此在代理中做一层拦截, 一旦发现非数字类型的参数就抛出错误; 此外, 该函数也不能被用做构造函数, 因此一旦触发 construct 陷阱亦直接抛出错误.zz</p>
<pre><code class="language-ts">const sum = (...arr) =&gt; arr.reduce((acc, val) =&gt; acc + val, 0)

const proxy = new Proxy(sum, {
  apply(trapTarget, thisArg, argumentsList) {
    const isNotAllNumber = argumentsList.some((val) =&gt; typeof val !== &#39;number&#39;)

    if (isNotAllNumber) {
      throw new TypeError(&#39;必须是数字类型的数组!&#39;)
    }

    return Reflect.apply(trapTarget, thisArg, argumentsList)
  },

  construct(trapTarget, argumentsList, newTarget) {
    throw new TypeError(&#39;该函数不能用做构造函数!&#39;)
  },
})

console.log(sum(1, 2, 3, 4)) // 10
console.log(proxy(1, 2, &#39;a&#39;, 4)) // 抛出错误
console.log(new proxy(1, 2, &#39;a&#39;, 4)) // 抛出错误
</code></pre>
<h2 id="可被撤销的代理">可被撤销的代理</h2>
<p>上面所有的例子, 一旦创建了代理, 就不能再从目标对象上被解绑. 如果我们想在某些时候删除掉代理对象, 就可以使用<strong>可被撤销的代理</strong>.</p>
<pre><code class="language-ts">let target = {
  name: &#39;target&#39;,
}

// 创建一个可被撤销的代理
let { proxy, revoke } = Proxy.revocable(target, {
  // your trap
})

console.log(proxy.name) // &#39;target&#39;

revoke() // 代理被撤销
console.log(proxy.name) // 抛出错误
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/Z3_AfTy84h-ojhljnQJqIg">ES6 Proxy 可以做哪些有意思的事情？</a></p>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2020-05-17T13:47:33.937Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[简析 AMD / CMD / UMD / CommonJS / ES Module]]></title>
        <id>7e95f2ef-adb3-4d1c-a0dc-1b910682dd65</id>
        <link href="https://yanceyleo.com/post/7e95f2ef-adb3-4d1c-a0dc-1b910682dd65"/>
        <updated>2021-07-07T09:08:31.653Z</updated>
        <summary type="html"><![CDATA[现代的前端项目一般都在采用 ES Module, 不过对于配置文件大多都在使用 CommonJS, 这边文章简析 AMD / CMD / CommonJS / ES Module 的发展史与异同.]]></summary>
        <content type="html"><![CDATA[<h2 id="commonjs-和-es-module-的区别">CommonJS 和 ES Module 的区别</h2>
<p>CommonJS 模块输出的是一个<strong>值的拷贝</strong>, ES6 模块输出的是<strong>值的引用</strong></p>
<p>下面的例子, mod.incCounter() 不会影响 mod.counter, 对于基本数据类型, CommonJS 模块无论加载多少次, 都只会在第一次加载时运行一次, 以后再加载, 返回的都是第一次运行结果的缓存, 除非手动清除系统缓存.</p>
<pre><code class="language-ts">// lib.js
var counter = 3
function incCounter() {
  counter++
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
}

// main.js
var mod = require(&#39;./lib&#39;)
console.log(mod.counter) // 3
mod.incCounter()
console.log(mod.counter) // 3
</code></pre>
<p>如果是个对象, 修改里面的值, 会影响原对象.</p>
<pre><code class="language-ts">// lib.js
var obj = { name: &#39;Yancey&#39;, age: 18 }
function incCounter() {
  obj.name = &#39;Leo&#39;
}
module.exports = {
  obj: obj,
  incCounter: incCounter,
}

// main.js
var mod = require(&#39;./lib&#39;)
console.log(mod.obj) // { name: &#39;Yancey&#39;, age: 18 }
mod.incCounter()
console.log(mod.obj) // { name: &#39;Leo&#39;, age: 18 }
</code></pre>
<p>如果把对象改成其他类型, 原变量不受响应.</p>
<pre><code class="language-ts">// lib.js
var obj = { name: &#39;Yancey&#39;, age: 18 }
function incCounter() {
  obj = &#39;沙雕&#39;
}
module.exports = {
  obj: obj,
  incCounter: incCounter,
}

// main.js
var mod = require(&#39;./lib&#39;)
console.log(mod.obj) // { name: &#39;Yancey&#39;, age: 18 }
mod.incCounter()
console.log(mod.obj) // { name: &#39;Yancey&#39;, age: 18 }
</code></pre>
<p>JS 引擎对脚本静态分析的时候, 遇到模块加载命令 import 就会生成一个只读引用. 等到脚本真正执行的时候, 再根据这个只读引用到被加载的模块中取值. 因此, ES6 模块是动态引用, 并且不会缓存值, 模块里的变量绑定其所在的模块.</p>
<pre><code class="language-ts">// lib.js
export let counter = 3
export function incCounter() {
  counter++
}

// main.js
import { counter, incCounter } from &#39;./lib&#39;
console.log(counter) // 3
incCounter()
console.log(counter) // 4
</code></pre>
<p>ES6 输入的模块变量只是一个&quot;符号连接&quot;, 所以这个变量是只读的, 对它重新赋值会报错</p>
<pre><code class="language-ts">// lib.js
export let obj = {}

// main.js
import { obj } from &#39;./lib&#39;
obj.prop = 123 // 可以
obj = {} // 报错
</code></pre>
<p>CommonJS 是<strong>运行时加载</strong>, 这种特性不能使用 Tree-shaking; ES6 Module 是<strong>编译时输出接口</strong>, 可使用 Tree-shaking</p>
<pre><code class="language-ts">const { stat, readFile } = require(&#39;fs&#39;)

// 等价于
const _fs = require(&#39;fs&#39;)
const stat = _fs.stat
const readFile = _fs.readFile
</code></pre>
<h2 id="amd">AMD</h2>
<p>使用 <code>require.js</code></p>
<pre><code class="language-ts">// 定义没有依赖的模块
define(function () {
  return 模块
})

// 定义有依赖的模块
define([&#39;module1&#39;, &#39;module2&#39;], function (m1, m2) {
  return 模块
})

//引入使用模块
require([&#39;module1&#39;, &#39;module2&#39;], function (m1, m2) {
  // 使用m1/m2
})
</code></pre>
<h2 id="cmd">CMD</h2>
<p>使用 <code>sea.js</code></p>
<pre><code class="language-ts">// 定义没有依赖的模块
define(function (require, exports, module) {
  exports.xxx = value
  module.exports = value
})

// 定义有依赖的模块
define(function (require, exports, module) {
  // 引入依赖模块(同步)
  var module2 = require(&#39;./module2&#39;)
  // 引入依赖模块(异步)
  require.async(&#39;./module3&#39;, function (m3) {})
  // 暴露模块
  exports.xxx = value
})

// 引入使用模块
define(function (require) {
  var m1 = require(&#39;./module1&#39;)
  var m4 = require(&#39;./module4&#39;)
  m1.show()
  m4.show()
})
</code></pre>
<h2 id="cmd-和-amd-的异同">CMD 和 AMD 的异同</h2>
<ul>
<li><p>相同点: 都是异步加载</p>
</li>
<li><p>不同点: AMD 依赖前置, 提前执行, js 可以方便知道依赖模块是谁, 立即加载; 而 CMD 就近依赖, 需要使用把模块变为字符串解析一遍才知道依赖了那些模块</p>
</li>
</ul>
<h2 id="umd">UMD</h2>
<p>所谓UMD (Universal Module Definition), 就是一种 JavaScript 通用模块定义规范, 让你的模块能在 JavaScript 所有运行环境中发挥作用.</p>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2020-05-09T09:58:07.135Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[[HTTP 系列] 第 3 篇 —— HTTP 缓存那些事]]></title>
        <id>89731d8e-5510-4094-8962-462b127ed5d0</id>
        <link href="https://yanceyleo.com/post/89731d8e-5510-4094-8962-462b127ed5d0"/>
        <updated>2021-04-27T04:49:33.041Z</updated>
        <summary type="html"><![CDATA[这里是《写给前端工程师的 HTTP 系列》，记得有位大佬曾经说过：“大厂前端面试对 HTTP 的要求比 CSS 还要高”，由此可见 HTTP 的重要程度不可小视。文章写作计划如下，视情况可能有一定的删减，本篇是该系列的第 3 篇 —— 《深入理解 HTTP 的缓存机制》。]]></summary>
        <content type="html"><![CDATA[<h2 id="从一张图片的响应头说起">从一张图片的响应头说起</h2>
<p><img src="https://edge.yancey.app/beg/Jietu20190507-164837%402x.jpg" alt="一个响应头的例子"></p>
<p>下面是一张图片的响应头, 我们复习一下各个字段:</p>
<ul>
<li><p>Accept-Ranges: 该字段告知客户端, 服务器是否能处理范围请求, 当可以处理时其值为 <code>bytes</code>, 否则为 <code>none</code>.</p>
</li>
<li><p>Connection: 该字段决定当前的事务完成后, 是否会关闭网络连接. 如果该值是 <code>keep-alive</code>, 网络连接就是持久的, 不会关闭, 使得对同一个服务器的请求可以继续在该连接上完成. 此外它还可以控制不再转发给代理的首部字段.</p>
</li>
<li><p>Content-Length: 该字段表明实体主体的大小, 单位是字节.</p>
</li>
<li><p>Content-MD5: 该字段用于检查报文主体在传输过程中是否保持完整性, 以及确认传输到达. 服务端对报文主体执行 MD5 算法, 获取一个 128 位的二进制数, 再通过 base64 编码后将结果写入 Content-MD5 字段值. 因为 HTTP 首部无法记录二进制值, 因此需要通过 Base64 进行处理. 客户端在接收到响应后再对报文主体执行一次相同的 MD5 算法. 将计算值于该字段值比较, 即可判断出报文主体的准确性.</p>
</li>
<li><p>Content-Type: 报文主体的格式.</p>
</li>
<li><p>Date: 表示创建报文的日期和时间.</p>
</li>
<li><p>ETag: 该值是将资源以字符串的形式作唯一标识, 服务器给每份资源分配对应的 ETag 值. 当资源更新时, ETag 值也会更新. ETag 有 <code>强 ETag</code> 和 <code>弱 ETag</code> 之分, 前者一般用于静态文件, 后者的字段值起始会有 <code>W</code> 标志.</p>
</li>
<li><p>Last-Modified: 该字段为服务器认定的资源做出修改的日期及时间, 它的精度比 ETag 要低, 也就是如果响应头中同时包含 ETag 和 Last-Modified 时, 会以 ETag 为准.</p>
</li>
</ul>
<h2 id="什么是-http-缓存">什么是 HTTP 缓存</h2>
<p>当客户端向服务端请求资源时, 会先访问浏览器缓存, 如果浏览器有&quot;要请求资源&quot;的副本, 就可以直接从浏览器缓存中提取, 而不是从原始服务器中提取这个资源.</p>
<p>HTTP 缓存都是在第二次请求开始的. 第一次请求资源时, 服务器返回资源, 并在响应头中回传资源的缓存参数; 后续请求中, 浏览器判断这些请求参数, 命中强缓存就直接 200 from cache, 否则就把请求参数加到请求头中回传给服务器, 看是否命中协商缓存, 命中则返回 304, 并使用浏览器缓存, 否则服务器会返回新的资源.</p>
<p>根据是否需要向服务器重新发起请求来分类, 可分为<strong>强制缓存</strong>和<strong>协商缓存</strong>; 根据是否可以被单个或者多个用户使用来分类, 可分为<strong>私有缓存</strong>和<strong>共享缓存</strong>. 这篇文章我们主要来聊<strong>强制缓存</strong>和<strong>协商缓存</strong>.</p>
<p><img src="https://edge.yancey.app/beg/4845448-ab0e961921da5694.png" alt="强缓存和协商缓存"></p>
<h2 id="强缓存">强缓存</h2>
<p>通过上面这张图, 我们知道强缓存由响应头中的 <code>Pragma</code>, <code>Cache-Control</code> 和 <code>Expires</code> 控制, 因为 <code>Pragma</code> 已经在 HTTP1.1 被废弃了, 这里不做讨论.</p>
<p>对于 <code>Cache-Control</code> 和 <code>Expires</code>, 如果两者都存在, 且 <code>Cache-Control</code> 设置了 max-age 或者 s-max-age, 那么 <code>Expires</code> 头会被忽略. <strong>也就是说 <code>Cache-Control</code> 的优先级要比 <code>Expires</code> 高</strong>, 这是因为后者用的是<strong>服务器时间</strong>, 这就导致客户端跟服务端的时间不一致而发生错误; 此外, 在缓存未失效前, <code>Expires</code> 无法获取到修改后的资源.</p>
<p>两个字段本质上都是告知客户端对比本地时间和服务器返回的生存时间来检测缓存是否可用, 如果缓存没有超过它的生存时间, 响应的副本会一直被保存. 当超过指定的时间后, 缓存服务器在请求发送过来时, 转向源服务器请求资源.</p>
<p>下面简单复习一下请求头中的 Cache-Control:</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>指令值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>max-age=[秒]</td>
<td>必填</td>
<td>设置缓存存储的最大周期, 超过这个时间缓存被认为过期, 该指令优先级高于 <code>Expires</code>, 并且它传递的是一个相对时间, 而 <code>Expires</code> 传递的是一个未来的时间.</td>
</tr>
<tr>
<td>max-stale(=[秒])</td>
<td>选填</td>
<td>在这个已过期的时间段之内, 客户端愿意接收一个已经过期的资源</td>
</tr>
<tr>
<td>min-fresh=[秒]</td>
<td>必填</td>
<td>表示客户端希望在指定的时间内获取最新的响应.</td>
</tr>
<tr>
<td>no-cache</td>
<td>选填</td>
<td>表示客户端不会接收缓存过的响应, 并且强制代理服务器将把客户端的请求转发给源服务器.</td>
</tr>
<tr>
<td>no-store</td>
<td>无</td>
<td>不缓存请求或响应中的任何内容(注意这个才是告知浏览器不缓存资源).</td>
</tr>
<tr>
<td>no-transform</td>
<td>无</td>
<td>代理服务器不得对资源进行转换或转变, 比如 Content-Encoding, Content-Range, Content-Type 等字段信息.</td>
</tr>
<tr>
<td>only-if-cached</td>
<td>无</td>
<td>客户端只接受已缓存的响应, 并且不要向原始服务器检查是否有更新的拷贝, 若没有命中缓存, 则返回 504 状态码 (Gateway Timeout).</td>
</tr>
</tbody></table>
<h2 id="协商缓存">协商缓存</h2>
<p>当第一次请求时服务器返回的响应头中符合如下三个条件之一, 浏览器第二次请求时就会与服务器进行协商, 即与服务端对比判断资源是否进行了修改更新.</p>
<ul>
<li><p>没有 Cache-Control 和 Expires</p>
</li>
<li><p>Cache-Control 和 Expires 已经过期</p>
</li>
<li><p>Cache-Control 的属性值为 no-cache 时(即不走强缓存)</p>
</li>
</ul>
<p>如果服务器端的资源没有修改, 就返回 304, 那么浏览器可以使用缓存中的数据, 否则直接返回 200 和新的资源. 跟协商缓存相关的头部属性有 <code>ETag/If-Not-Match</code> 和 <code>Last-Modified/If-Modified-Since</code>, 他们是成对出现的. 其中 <code>ETag</code> 和 <code>Last-Modified</code> 是请求头中的字段, 而 <code>If-Not-Match</code> 和 <code>If-Modified-Since</code> 是响应头中的字段, 下图是对两者的比较.</p>
<p><img src="https://edge.yancey.app/beg/4845448-a22cef109d00aa79-2.jpeg" alt="ETag/If-Not-Match 和 Last-Modified/If-Modified-Since 对比"></p>
<p>协商缓存的流程是这样的: 当浏览器第一次向服务器发送请求时, 会在响应头中返回协商缓存的头属性: ETag 和 Last-Modified, 其中 ETag 返回的是一个 hash 值, Last-Modified 返回的是 GMT 格式的最后修改时间; 在后续的请求中, 会在请求头上带上 If-Not-Match 和 If-Modified-Since, 服务器在接收到这两个参数后会做比较, 如果返回的是 304 状态码, 则说明请求的资源没有修改, 浏览器可以直接在缓存中取数据, 否则, 服务器会直接返回数据.</p>
<p><img src="https://edge.yancey.app/beg/4845448-c2d84719d423f269.jpeg" alt="协商缓存请求头"></p>
<p><img src="https://edge.yancey.app/beg/4845448-45287e60a17830db.png" alt="协商缓存响应头"></p>
<p>为什么有了 Last-Modified 还需要 ETag 呢? ETag/If-Not-Match 是在 HTTP/1.1 出现的, 主要是修正 Last-Modified 一些不准确的问题:</p>
<ul>
<li><p>Last-Modified 标注的最后修改只能精确到秒级, 如果某些文件在 1 秒钟以内, 被修改多次的话, 它将不能准确标注文件的修改时间</p>
</li>
<li><p>如果某些文件被修改了, 但是内容并没有任何变化, 而 Last-Modified 却改变了, 导致文件没法使用缓存</p>
</li>
<li><p>有可能存在服务器没有准确获取文件修改时间, 或者与代理服务器时间不一致等情形</p>
</li>
</ul>
<h2 id="html-文件如何使用缓存">HTML 文件如何使用缓存</h2>
<p>HTML 禁用缓存:</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt;
</code></pre>
<p>HTML 设置缓存:</p>
<pre><code class="language-html">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;max-age=7200&quot; /&gt;
</code></pre>
<h2 id="用户行为对浏览器缓存的影响">用户行为对浏览器缓存的影响</h2>
<p>所谓用户行为对浏览器缓存的影响, 指的就是用户在浏览器如何操作时, 会触发怎样的缓存策略. 主要有 3 种:</p>
<ul>
<li><p>打开网页, 地址栏输入地址: 查找 disk cache 中是否有匹配. 如有则使用；如没有则发送网络请求.</p>
</li>
<li><p>普通刷新(Command + R): 因为 TAB 并没有关闭, 因此 memory cache 是可用的, 会被优先使用(如果匹配的话). 其次才是 disk cache.</p>
</li>
<li><p>强制刷新(Command + Shift + R): 浏览器不使用缓存, 因此发送的请求头部均带有 Cache-control: no-cache(为了兼容, 还带了 Pragma: no-cache), 服务器直接返回 200 和最新内容.</p>
</li>
</ul>
<h2 id="私有缓存和共享缓存">私有缓存和共享缓存</h2>
<p>私有缓存(浏览器级缓存): 私有缓存只能用于单独用户. 你可能已经见过浏览器设置中的“缓存”选项. 浏览器缓存拥有用户通过 HTTP 下载的所有文档. 这些缓存为浏览过的文档提供向后/向前导航, 保存网页, 查看源码等功能, 可以避免再次向服务器发起多余的请求. 它同样可以提供缓存内容的离线浏览, 并且只能用于单独的用户.</p>
<pre><code class="language-html">Cache-Control: Private
</code></pre>
<p>共享缓存(代理级缓存): 共享缓存可以被多个用户使用. 例如, ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户. 这样热门的资源就会被重复使用, 减少网络拥堵与延迟. 共享缓存可以被多个用户使用.</p>
<pre><code class="language-html">Cache-Control: Public
</code></pre>
<h2 id="vary-accept-encoding">Vary: Accept-Encoding</h2>
<p>当一个资源启用了 gzip 压缩, 并且被代理服务器缓存, 客户端如果不支持 gzip 压缩, 那么在这样的情况下将会得到不正确的数据(也就是压缩过的数据). 这将会使代理服务器缓存两个版本的资源: 一个是压缩过的, 一个是没压缩过的. 正确版本的资源将在请求头发送之后进行传输.</p>
<p>此外: IE 浏览器不缓存任何带有 Vary 头但值不为 Accept-Encoding 和 User-Agent 的资源. 所以通过这种方式添加这个头, 才能确保这些资源在 IE 下被缓存.</p>
<h2 id="加餐-keep-alive">加餐: keep-alive</h2>
<p>在 http 早期, 每个 http 请求都要求打开一个 tcp socket 连接, 并且使用一次之后就断开这个 tcp 连接.</p>
<p>使用 keep-alive 可以改善这种状态, 即在一次 TCP 连接中可以持续发送多份数据而不会断开连接. 通过使用 keep-alive 机制, 可以减少 tcp 连接建立次数, 也意味着可以减少 TIME_WAIT 状态连接, 以此提高性能和提高 httpd 服务器的吞吐率.</p>
<p>但是, keep-alive 并不是银弹, 长时间的 tcp 连接容易导致系统资源无效占用. 配置不当的 keep-alive, 有时比重复利用连接带来的损失还更大. 所以, 正确地设置 <code>keep-alive timeout</code> 时间非常重要.</p>
<h3 id="keep-alive-timeout">keep-alive timeout</h3>
<p>Httpd 守护进程, 一般都提供了 keep-alive timeout 时间设置参数. 比如 nginx 的 keepalive_timeout, 和 Apache 的 KeepAliveTimeout. 这个 keepalive_timout 时间值意味着: 一个 http 产生的 tcp 连接在传送完最后一个响应后, 还需要 hold 住 keepalive_timeout 秒后, 才开始关闭这个连接.</p>
<p>当 httpd 守护进程发送完一个响应后, 理应马上主动关闭相应的 tcp 连接, 设置 keepalive_timeout 后, httpd 守护进程会想说: &quot;再等等吧, 看看浏览器还有没有请求过来&quot;, 这一等, 便是 keepalive_timeout 时间. 如果守护进程在这个等待的时间里, 一直没有收到浏览发过来 http 请求, 则关闭这个 http 连接.</p>
<h2 id="总结">总结</h2>
<p>最后用一张图总结缓存机制:</p>
<p><img src="https://edge.yancey.app/beg/6.jpg" alt="缓存机制"></p>
<h2 id="参考">参考</h2>
<p>《图解 HTTP》 -- 上野 宣</p>
<p><a href="https://ddduanlian.github.io/2018/06/22/http_note/">HTTP 协议知识点总结</a></p>
<p><a href="https://juejin.im/post/5c6e77da6fb9a049db73bb07">【前端词典】从输入 URL 到展现涉及哪些缓存环节(非常详细)</a></p>
<p><a href="http://www.nowamagic.net/academy/detail/23350305">HTTP Keep-Alive 是什么？如何工作？</a></p>
<p><a href="https://www.jianshu.com/p/227cee9c8d15">一文读懂 http 缓存（超详细）</a></p>
<p><a href="https://www.jianshu.com/p/54cc04190252">深入理解浏览器的缓存机制</a></p>
]]></content>
        <author>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </author>
        <contributor>
            <name>Yancey Leo</name>
            <email>yanceyofficial@gmail.com</email>
            <uri>https://yanceyleo.com/</uri>
        </contributor>
        <published>2020-05-08T02:27:29.227Z</published>
        <rights>Copyright (c) 2021 Yancey Inc. and its affiliates.</rights>
    </entry>
</feed>